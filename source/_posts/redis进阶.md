---
title: redis进阶
date: 2019-10-05 14:26:00
tags: 
  - redis
categories: 
  - 计算机
---

### 发布订阅 publish/subscribe

![publish](E:\folder\themes\next\source\images\publish.png)



1发布一条消息，2开始订阅，此时不会收到刚刚发布的消息 3 再次发布消息 此时订阅端才会收到发布的消息。订阅后不能看到订阅之前发布的消息。

### 事务

```
multi //开启事务
set k1 123
exec //执行事务
```

### 布隆过滤器

布隆过滤器是一个bitmap,集合元素通过几种不同的哈希函数生成的哈希值映射到bit位设为1。只要有一个哈希值对应的bit位为0时就会认为不存在此元素。

可以使用布隆过滤器预防穿透，但是布隆过滤器不会保证百分百准确同时也不支持删除。

### redis缓存

缓存：1不是全量数据2缓存应该存放热数据3数据可以丢4 追求极速

数据库：1全量数据2数据不能丢3追求速度+持久性

回收策略:

- noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）(做数据库时使用此策略)

- allkeys-lru: 尝试回收最久使用的键（LRU），使得新添加的数据有空间存放。

- volatile-lru: 尝试回收最久使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。

- allkeys-lfu:从所有键中驱逐使用频率最少的键。

- volatile-lfu:从所有配置了过期时间的键中驱逐使用频率最少的键。

- allkeys-random: 回收随机的键使得新添加的数据有空间存放。

- volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。

- volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

  根据业务来选择使用哪种策略，一般使用lru及lfu策略。

过期: 如果没有到达过期时间，发生写操作，那么过期时间会被剔除

过期判断原理: 1如果key已经过期，那么当客户端尝试访问时，key会被发现并主动过期

   					2周期轮询判定，直到过期的key的百分比低于25%

### redis持久化

#### RDB

rdb持久化方式能够在指定时间间隔对数据进行快照，具有时点性,通过SAVE和BGSAVE对数据集进行保存。

SAVE命令会阻塞redis的服务进程，直到rdb文件创建完毕为止。只有在目的明确时才使用，如关机等。

BGSAVE命令则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。

工作原理：

- Redis 调用forks. 同时拥有父进程和子进程。
- 子进程将数据集写入到一个临时 RDB 文件中。
- 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。

这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。

rdb只有一个dump.rdb文件，如需历史数据需要手动维护。

【管道】管道是阻塞的，会触发子进程。常规下linux进程间数据是隔离的。

使用系统调用:fork()会产生一个新的子进程，子进程只会开辟一个虚拟空间，而物理空间(内核)是和父进程共享的（指向同一个指针），只有当进程的数据发生变化时才会在物理空间复制一份新的数据并在此空间进行写操作。这利用了copy on write（写时复制）,只有在数据变化写入时才会发生复制。

#### AOF（Append-only file）

每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。

工作原理：

- Redis 执行 fork() ，现在同时拥有父进程和子进程。
- 子进程开始将新 AOF 文件的内容写入到临时文件。
- 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。
- 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
- 现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。

|      | 丢失数据                       | 恢复速度               |
| ---- | ------------------------------ | ---------------------- |
| RDB  | 会丢失一个时点的数据，相对较大 | 体积相对小，恢复速度快 |
| AOF  | 丢失数据少                     | 体积相对大，恢复速度慢 |

推荐使用AOF和RDB两种方式，配置文件修改属性aof-usr-rdb-preamble yes表示开启AOF、RDB混合模式。这种模式只会生成一个aof文件，aof文件包含rdb及增量指令。只有触发BGREWRITEAOF 时aof才会包含rdb.如下：

![aofrewite](E:\folder\themes\next\source\images\aofrewite.png)

### 主从复制

主备、主从、主主概念可参考<https://www.cnblogs.com/tankblog/p/11190598.html>

主从和主备的区别是除了同步数据之外还得干活，对外提供读的操作。

REPLICAOF  hostname port  当前服务器作为指定服务器的副本

 REPLICAOF NO ONE 设置当前服务器为主服务器

#### sentinel (哨兵)

sentinel是解决redis高可用的方案,可以监视多个主服务器及主服务器的从服务器，可以在主服务器挂掉的时候指定新的主服务器。

```
//创建sentinel配置文件
port 26379 //指定端口号
//指定监听主服务器(本地6279端口)，2代表当有2个哨兵认为master失效时，master才算失效
sentinel monitor mymaster localhost 6379 2 

//启动哨兵
redis-cli sentinel.conf --sentinel
```

如果主挂了哨兵会重新选一个主，然后让其他从跟随,哨兵(通过发布订阅)知道当前redis会有其他几个哨兵。

#### 分区/分片

redis集群中内置了 16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽.

使用哈希槽的好处就在于可以方便的添加或移除节点。

当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；

当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；

### 扩展

redis存在问题：单机故障，容量有量，压力

#### AKF

AKF扩展立方、分别从XYZ轴展开，可以解决redis存在的问题

X轴:主从复制、高可用，通过克隆进行扩展

Y轴:业务拆分，通过拆分不同的东西进行扩展

Z轴:地域性划分，通过拆分相似的东西进行扩展

#### 脑裂

脑裂:高可用集群故障，由一个整体拆分成两部分都可以对外提供服务，导致数据不一致。搭建集群时设定的数量是奇数，可以防止脑裂。

例：AB两机房由于网络中断，分别对外提供服务。则对A进行插入操作，从B读取不到数据。如果A中的机器数量占整个集群的一半以上，那么B会自动宕机，由A来对外提供服务。

#### CAP（分布式的三大特性）

Consistency(一致性): 读取的数据是写入的数据。

Availability(可用性):只要收到用户的请求，服务器就必须给出回应。

Partition tolerance(分区容忍性):必然存在网络故障断开的风险，这个网络断开的专业场景成为网络分区。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

CAP 原则指的是，这三个要素最多只能同时实现两点，实际只能保证CP、AP。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。

#### 一致性哈希算法

将哈希值空间组织成一个虚拟的圆环，将每台机器通过哈希算法映射到圆环上(物理节点)，将数据通过哈希算法映射到圆环，按顺时针找到下一个物理节点存储此数据。但不能保证每台机器数据分布均匀，可能会集中在某台机器上。这时可为每台机器虚拟出几个节点，这样会缓解数据倾倒。

#### 面试常问

##### 击穿

一个key或少量的key过期造成并发访问数据库.可以在客户端异步访问redis,第一个访问到的调用setnx(key timeout)从数据库取值,其他客户端访问如果没有得到值可更改setnx(key)的过期时间。

##### 穿透

查询数据是系统根本不存在的数据(黑客攻击)，可以使用布隆过滤器

##### 雪崩

大量的key同时失效.可以均匀设置过期时间，可以参考击穿方案使用分布式锁。

vim命令小技巧:  .,$y  表示复制当前行到末行 Gp 从最后一行开始粘贴

*工欲善其事*，必先利其器。要学会利用官方网站、github。