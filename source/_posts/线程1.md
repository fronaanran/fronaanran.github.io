---
title: 线程1
date: 2019-09-26 11:24:25
tags: 
  - java
  - 线程
categories: 
  - 计算机
---

## 创建方式

 1)继承Thread类   2)实现Runnable接口

```
public class TestThread {
    public static void main(String[] args) {
        T1 t1 = new T1();
        t1.setName("t1,继承Thread类");
        t1.start();//启动线程1
        T2 t2 = new T2();
        Thread thread = new Thread(t2);
        t1.setName("t2,实现Runnable接口");
        thread.start();//启动线程2
    }
}

class T1 extends Thread{
    @Override
    public void run(){
        System.out.println("当前线程名称:"+Thread.currentThread().getName());
    }
}

class T2 implements Runnable{
    @Override
    public void run() {
        System.out.println("当前线程名称:"+Thread.currentThread().getName());
    }
}
```

## 线程状态

1. New
2. Runnable,细分为ready和running,调用start()方法进入ready,获得使用权后进入running
3. Block,分为等待阻塞，超时等待阻塞及其他阻塞。调用sleep,wait等方法会造成阻塞
4. Teminated

## 常用方法

join:暂停当前线程，执行join线程，等join线程执行完毕继续执行当前线程

```
public class TestJoinThread {
    public static void main(String[] args) {
        Thread t1 = new T1();
        t1.start();
        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程执行");
    }
}
class T1 extends Thread{
    @Override
    public void run(){
        for (int i=0;i<100;i++){
            System.out.println("t1,第"+i+"次开始执行");
        }

    }
    //执行结果t1执行100次之后输出主线程执行，主线程要等到t1线程执行结束再执行
```

join方法可以使线程按自己定义的顺序执行

sleep和wait方法的区别：

- sleep属于Thread类的静态方法；wait属于Object类的方法 
- sleep不释放锁，使用interrupt方法打断；wait释放锁，会造成阻塞，使用notify方法唤醒

## 同步

多个线程抢占同一资源需要加锁即synchronized，保证原子性。

锁升级：偏向锁、轻量级锁、重量级锁

有一个线程时会使用偏向锁，有线程竞争后会升级为轻量级锁，未获得锁的线程会自旋，当达到设定的自旋次数后依旧没有获得锁，会升级为重量级锁。

线程少、方法执行时间短的时候会使用轻量级锁，会占用cpu资源

线程多，执行时间长会使用重量级锁，不占用cpu资源，但会增加用户态和内核态的切换次数，系统开销比较大

## 生产者消费者案例

篮子存放牛奶，生产者把牛奶放入篮子，消费者从篮子取出牛奶

```
public class TestSync {
    public static void main(String[] args) {
        Basket b = new Basket();
        new Thread(new Producer(b)).start();
        new Thread(new Consumer(b)).start();
    }
}
//牛奶
class Milk{
    int id;
    Milk(int id){
        this.id = id;
    }

    @Override
    public String toString() {
        return "Milk:"+id;
    }
}
/**
 *  篮子，篮子存放8盒牛奶，有放入和取出方法
 *  涉及到同步，等待，唤醒,
 *  第1，2处使用while不使用if是因为会反复确认条件是否成立再向下执行
 */
class Basket{
    Milk[] milks = new Milk[8];
    int index = 0;
    public synchronized void push(Milk m){
        while(index == milks.length){  //第1处
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        this.notify();
        System.out.println("生产了:"+index);
        milks[index] = m;
        index++;
    }
    public synchronized Milk pop(){
        while(index == 0){ //第2处
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        this.notify();
        index--;
        System.out.println("消费了:"+index);
         return milks[index];
    }
}
//生产者，生产牛奶放入篮子
class Producer implements Runnable{
    Basket b = new Basket();
    Producer(Basket basket){
        this.b = basket;
    }
    @Override
    public void run() {
        for(int i=0;i<10;i++){
            b.push(new Milk(i));
        }
    }
}
//消费者，从篮子里拿出牛奶
class Consumer implements Runnable{
    Basket b = new Basket();
    Consumer(Basket basket){
        this.b = basket;
    }
    @Override
    public void run() {
        for(int i=0;i<10;i++){
            b.pop();
        }
    }
}
```

