<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2019%2F12%2F31%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[lambda、streamlambda表达式可以替代只有一个抽象函数的接口实现，告别匿名内部类，代码看起来更简洁易懂 lambda表达式同时还提升了对集合、框架的迭代、遍历、过滤数据的操作 函数式接口 有且仅有一个抽象方法的接口叫做函数式接口。lambda表达式应用于任何有函数式接口的地方 1234567891011121314Runnable runnable = new Runnable() &#123;@Overridepublic void run() &#123;System.out.println(&quot;running...&quot;);&#125;&#125;;runnable.run();Runnable runnable1 = ()-&gt; System.out.println(&quot;running2&quot;);runnable1.run();//lambda用例()-&gt;&#123;&#125;()-&gt;&#123;return 100;&#125;()-&gt;100()-&gt;null(int x)-&gt;x+1x-&gt;x+1 方法引用 类名::方法名,实例对象::方法名 例:System.out::println stream之流操作 123456789101112131415161718List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);list.stream().filter(x-&gt;x%2==0).forEach(System.out::println);System.out.println(list.stream().filter(x -&gt; x % 2 == 1).mapToInt(x -&gt; x).sum());2 4 9//不会缓存中间结果，即返回值为Stream时的语句不会执行，只有执行终止语句才会执行streamStream&lt;Integer&gt; integerStream = list.stream().filter((x) -&gt; &#123;System.out.println(&quot;运行。。。&quot;);return x % 2 == 0;&#125;);System.out.println(integerStream);//不会执行filter中的语句，因为此语句的返回结果是stream属于中间操作，不会被缓存，只有对stream进行操作后返回非stream值时才会执行相应语句。System.out.println(integerStream.findFirst().get());//会执行filter的语句，因为.get()最后的返回值是一个int值.//把满足条件的值放到一个集合中List&lt;Integer&gt; collect = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toList());collect.forEach(System.out::println);//求数值相加和String str=&quot;11,22,33,44,55&quot;;System.out.println(Arrays.stream(str.split(&quot;,&quot;)).mapToInt(Integer::valueOf).sum());System.out.println(Arrays.stream(str.split(&quot;,&quot;)).map(Integer::valueOf).mapToInt(x -&gt; x).sum()); 自定义注解 使用@interface 来定义 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 元注解的作用是负责注解其他注解，java中定义了四个标准的元注解: @Target:用来描述注解的使用范围(注解可以用在什么地方) @Retention:表示需要在什么级别保存该注释信息，描述注解的生命周期 Source&lt;Class&lt;Runtime @Document:说明该注解将被包含在javadoc中 @Inherited:说明子类可以继承父类中的该注解]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js士兵行走案例]]></title>
    <url>%2F2019%2F12%2F31%2Fjs%E5%A3%AB%E5%85%B5%E8%A1%8C%E8%B5%B0%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;style&gt; *&#123; margin:0; padding:0; &#125; div&#123; position: absolute; width: 50px; height: 100px; background-image: url(&quot;./js/sb.png&quot;); background-position: 0px -200px; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //创建士兵 function Soldier()&#123; this.x=0; this.l=0; this.top=parseInt(Math.random()*500); this.isMove=true; this.init(); arr.push(this); this.click(); &#125; //动态创建div Soldier.prototype.init=function()&#123; this.dom =document.createElement(&quot;div&quot;); this.dom.style.top=this.top+&quot;px&quot;; document.body.appendChild(this.dom) &#125; //士兵行走 Soldier.prototype.walk=function()&#123; if(!this.isMove) return; if(this.x++ &gt;3) this.x=0; this.l+=10; if(this.l&gt;500)&#123; arr.splice(arr.indexOf(this),1); document.body.removeChild(this.dom); &#125; this.dom.style.backgroundPosition=-this.x*50+&quot;px -200px&quot;; this.dom.style.left=this.l+&quot;px&quot;; &#125; //定时行走 var time=0; var arr=[]; setInterval(function()&#123; if(time++ % 10 == 0)&#123; new Soldier(); &#125; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].walk(); &#125; &#125;,100) //点击事件 Soldier.prototype.click=function()&#123; var self=this; this.dom.onclick=function()&#123; self.isMove=!self.isMove; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javase知识点总结]]></title>
    <url>%2F2019%2F12%2F31%2Fjavase%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93(%E6%9D%82)%2F</url>
    <content type="text"><![CDATA[二进制，数据进行计算时是以二进制来计算的，确切来说负数是根据反码来计算的，正数的补码、原码、反码是同一个，负数的原码最高位为1其他位和正数一样，反码为原码取反(不包含最高位)，补码为反码+1。 12340010 0011 //35的原码、反码、补码1010 0011 //-35的原码1101 1100 //-35的反码1101 1101 //-35的补码 n&gt;&gt;2 相当于n/4,n&lt;&lt;2相当于n*4 面向对象的主要目标：可维护性、可重用性、可扩展性 封装(维护性)继承(复用性)多态(扩展性) 外部类与内部类class文件使用$符号分隔 组合 强调整体 头是身体组合的一部分，不可分，具有相同的生命周期 聚合 小狗和狗绳，狗绳可复用于另一条小狗 数据对象转换为二进制流的过程称为对象的序列化 二进制流恢复为对象称之为反序列化 成员变量默认有初始值，局部变量需要自定义初始值 冒泡排序及选择排序(伪代码) 123456789101112131415161718192021222324//冒泡排序，相邻两数进行比较，最大的放在后边for(int i=0;i&lt;str.length;i++)&#123; //外层控制循环次数 for(int j=0;j&lt;str.length-1-i;j++)&#123;//内层控制每次的比较次数 if(a[j]&gt;a[j+1])&#123; int tmp = a[j]; a[j]=a[j+1]; a[j+1]=tmp; &#125; &#125;&#125;//选择排序，第一次会跟后面的每一个值进行比较，找到最小值，依此类推。。。for(int i=0;i&lt;str.length-1;i++)&#123; for(int j=i+1;j&lt;str.length;j++)&#123; if(a[i]&gt;a[j])&#123; int tmp=a[i]; a[i]=a[j]; a[j]=tmp; &#125; &#125;&#125;//a=1,b=2 不借助第三方变量交换ab值的方法a=a+b;b=a-b;a=a-b; 重载是当1)参数个数不同2)参数类型不同3)参数顺序不同时成立 重载是编译期确定方法调用，重写在运行期由JVM进行动态绑定 多态：同一指令不同对象有不同反应。实现方式：父类引用子类对象。1)父类作为方法的参数2）父类作为方法的返回值类型 123456789Pet dog = new Dog();//父类引用子类对象public void feed(Pet pet)&#123; if(pet instanceof Dog)&#123;//instanceof通常和强制类型转换结合使用 pet.feed();//1)父类作为方法的参数 &#125;&#125;public Pet buy()&#123; return new Dog();//2)父类作为方法的返回值类型&#125; 接口中的变量都是静态常量，方法都是抽象方法 严格来讲java只有方法没有函数。方法即为类内的代码块，函数则是定义在类外(像python等可以直接定义函数，不需要创建类) 静态导包: 123import static Java.lang.math.*System.out.println(sqr(12));//直接使用方法名即可，不需要再加Math.sqr()System.out.println(abs(-12));//适用于本类中多次使用Math类中的方法 构造代码块{} 会默认添加到构造方法第一句，如果构造方法第一句是this()，则此构造不添加代码块的值 栈溢出：不断调用方法，不断压栈超出栈深度，如递归、死循环等 堆溢出：大量创建对象不回收、jvm设置不合理等 高内聚，低耦合 高内聚：模块的内聚反应模块内部联系的紧密程度，只负责一项任务，不要过分关心其他业务 低耦合：对外部依赖尽可能的少，模块独立存在 初始化过程：父类静态、子类静态、父类属性、父类构造、子类属性、子类构造 123byte b=10;b=b+1;//编译错误，b+1是int类型，需要强转为byteb+=1; 反射是动态运行时可以获得类的属性、方法等，反射破坏了封装 生成Class对象的三种方式:Class.forName(“com.entity.Test”)、Test.class、new Test(). getClass() 1234567891011int a1=127int a2=128Integer a3 = new Integer(127)Integer a4 = new Integer(127)Integer a5 = new Integer(128)Integer a6=127Integer a7=127System.out.println(a1==a3)//true,a3会自动拆箱为int 127System.out.println(a2==a5)//false,Integer只缓存-128-127之间的数System.out.println(a3==a4)//false,new对象比较的是两个地址值System.out.println(a6==a7)//true String，StringBuilder,StringBuffer String是不可变字符串 StringBuilder和StringBuffer是可变字符串。前者是线程不安全的，后者是线程安全的。 StringBuilder、StringBuffer、ArrayList扩容时都是使用数组的拷贝,Array.copy完成的。 抽象类实现接口不必实现接口的方法。 catch捕获异常后finally之后的代码依旧可以运行。 12345678910111213141516171819202122232425262728293031323334353637383940//案例1private static int test()&#123; int num = 10; try&#123; System.out.println(&quot;try&quot;); return num += 80;//先执行return后面的表达式 &#125;catch(Exception e)&#123; System.out.println(&quot;error&quot;); &#125;finally&#123; if (num &gt; 20)&#123; System.out.println(&quot;num&gt;20 : &quot; + num); &#125; System.out.println(&quot;finally&quot;); &#125; return num; &#125; try num&gt;20:90 finally 90//案例2 private static int test2()&#123; int num = 10; try&#123; System.out.println(&quot;try&quot;); return num;//返回的是try语句的num &#125;catch(Exception e)&#123; System.out.println(&quot;error&quot;); &#125;finally&#123; if (num &gt; 20)&#123; System.out.println(&quot;num&gt;20 : &quot; + num); &#125; System.out.println(&quot;finally&quot;); num = 100;//此num为finally里的局部变量 &#125; return num; &#125; try finally 10 List、Set、Map List有序、可重复，Set无序，不可重复，Map key-value键值对形式， 实现List的常用类包括ArrayList,LinkedList,Vector ArrayList数据结构是数组，查询快，添加、删除慢，线程不安全，效率高，默认10个大小，之后会1.5倍扩容 Vector数据结构是数组，查询快，添加、删除慢，线程安全，效率低，默认2倍扩容 LinkedList数据结构是链表，查询慢，添加、删除快，线程不安全，效率高 实现Set的常用类包括HashSet,TreeSet HashSet是基于哈希表实现的，无序，可以存放null值 TreeSet是基于红黑树实现的，有序，不能存放null值 ，底层对TreeMap做了一层封装 hashCode相同equals不一定相同，equals相同，hashCode一定相同 计算哈希值时会使用31进行计算，因为31二进制为11111,方便进行移位操作 重写hashCode可能会导致内存泄漏 1234person.age =10;//重写了hashcode方法set.add(person);//添加到set中person.age=30;set.remove(person);//此时person并没有被删除 set比较器: comparable内部比较器，需要定义在具体类中(Person)，且重写其compareTo方法 comparator外部比较器，需要定义在测试类中(TestComparator)，且重写其compare方法.comparator使用更加灵活，是策略模式的体现。 Collection集合继承Iteratable接口，实现其Iterator iterator()方法，Iterator中包含hasNext()、next()方法。 1234567891011121314151617public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(3); Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; Object o = iterator.next(); if(o.equals(1))&#123; list.remove(o); //ConcurrentModificationException异常 //iterator.remove(); &#125; &#125; for (Object o : list) &#123; System.out.println(o); &#125; &#125; 实现Map的常用类包括HashMap,HashTable,TreeMap HashMap无序，线程不安全，允许null值 ,默认大小16，扩容方式2倍 HashTable无序，线程安全，不允许null值,默认大小11，扩容2n+1 TreeMap有序 hashmap1.7中数据结构是链表，插入数据时为头插法，容易造成死循环 hashmap1.8中数据结构是链表+红黑树，插入数据时为尾插法 hashmap在new的时候不会初始化容量，在put时才会初始化容量。put方法(1.8)步骤: hashmap 默认初始长度为16，扩容时按照2的n次幂扩容。 长度为2的n次幂的原因:1)方便进行与运算操作提高效率以快速获取索引值，与运算比取模操作效率高。2）在扩容之后涉及元素迁移过程，迁移的时候只需要判断二进的前一位是0还是1即可。如果是0则下标不变，如果是1，则旧下标值+旧数组的长度即为新下标值。 1234h&amp;(n-1) //hashmap数组寻址时通过hash值和长度-1进行与运算，hash&amp;(n-1) == hash%n //与运算比取模效率高，与运算直接对内存数据进行操作，模运算需转成十进制例:13&amp;15=1101=13，13%15=13运算时n-1得到二进制位均为1，例15:1111,31:11111，这样方便进行与运算操作 线程池 为什么要使用线程池 1)使用线程池可以重复利用已有的线程继续执行任务，避免内存消耗 2)由于没有线程创建和销毁时的消耗，可以提高系统响应速度 3)通过线程可以对线程进行合理的管理，根据系统的承受能力调整可运行数量的大小等 工作原理及分类 线程池的生命周期 shutdown关闭状态不接受新任务，但会继续处理阻塞队列中已保存的任务 stop 不接受新任务，不处理阻塞队列中的任务，会中断当前执行的线程 常用队列 ArrayBlockingQueue、LinkedBlockingQueue、SynchronizedQueue、DelayQueue ArrayBlockingQueue:队列中的锁是共享的，即生产者和消费者共用一把锁，且必须指定队列大小 LinkedBlockingQueue:队列中的锁是分享的，生产者和消费者各用一把锁，不需要指定队列大小 SynchronizedQueue：无缓冲队列 execute和submit区别 void execute(Runnable),execute参数只能是Runnable类型，且没有返回值 Future&lt;&gt; submit(Callable),submit参数可以是Runnable,Callable,且返回值是Future类型,能得到返回值 java中方法传递是值传递 基本类型传递时，形参做改变，实参依旧原值 引用类型传递时：1)形参保持和实参同一地址引用，形参修改，实参值也会跟着改变 2)形参重新赋值，指向新的引用，实参值不变。 1234567891011public static void test(StringBuffer str)&#123; str= new StringBuffer(&quot;java&quot;);//1 指向新的引用，实参值无变化 //str.append(&quot;java&quot;);//2指向同一引用，实参值有变化&#125;public static void main(String[] args)&#123; StringBuffer str=new StringBuffer(&quot;hello&quot;); test(str); System.out.println(str);&#125;hellohello java 多线程技术和并发更多依赖操作系统的调配。并行依赖于cpu多核技术。 tcp建立连接需要三次握手，断开连接需要四次挥手， 三次握手目的是确保信息对等，防止超时，防止脏连接 四次挥手目的是确保被动方能顺利关闭，防止失效请求。连接都是通过文件描述符(fd)完成的。 (常见端口)HTTP 80 HTTPS 443 SSH 22 FTP 21 信息安全CIA原则 保密性(confidentiality)完整性(integnity)可用性(availability) 跨站脚本攻击 XSS 信息窃取破坏，在HTML页面执行提供的恶意代码 跨站请求伪造 CSRF 直接盗用用户浏览器的登录信息]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础]]></title>
    <url>%2F2019%2F10%2F05%2Fredis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本介绍Redis 是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件，支持多种类型的数据结构,是单进程，单实例。 memcache和redis对比： memcache &lt;key,value&gt; value没有类型的概念 redis &lt;key,value&gt; value支持多种类型的多种方法。 例：“person,{name:’小明’,age:18}”当客户端需要获取value中的age时，memcache会返回所有value值，让客户端去遍历所需要的值 ，而redis会直接返回value相对应的age。本质上解耦，体现计算向数据移动。 数据库排名网站 ：https://db-engines.com/en/ redis中文网站：http:redis.cn redis官方网站: https://redis.io/ 基本语法string读取(范围/批量):get k1 / getrange k1 3 -1 / mget k1 k2 赋值(范围/批量):set k1 hello / getrange k1 2 -1 / mset k2 222 k3 333 set key nx 不存在时赋值，在分步式锁时使用​ set key xx 存在时赋值 append,strlength等等字符串基本语法 数值：递增)incr k1 / incrby k1 22 递减)decr k1 / decrby k1 2 redis是二进制安全的，需要和客户端沟通好编码类型. bitmap(位图):setbit,getbit ,bitcount,bitop 0(第0个字节) 1(第1个字节) 00000000（8位） 00000000(8位) 123456789101112131415161718192021127.0.0.1:6379&gt; setbit k1 1 1 //第0个字节第2位设置为1 即01000000127.0.0.1:6379&gt; get k1&quot;@&quot;127.0.0.1:6379&gt; setbit k1 10 1 //第2个字节第3位设置为1 即01000000127.0.0.1:6379&gt; get k1&quot;@ &quot;127.0.0.1:6379&gt; bitcount k1 0 0 //k1第0个字节有几个1(integer) 1127.0.0.1:6379&gt; bitcount k1 0 1 //k1第0至1个字节有几个1(integer) 2127.0.0.1:6379&gt; setbit k2 1 1127.0.0.1:6379&gt; setbit k2 7 1127.0.0.1:6379&gt; get k2 //01000001&quot;A&quot;127.0.0.1:6379&gt; setbit k3 1 1127.0.0.1:6379&gt; setbit k3 6 1127.0.0.1:6379&gt; get k3 //01000010&quot;B&quot;127.0.0.1:6379&gt; bitop and destkey k2 k3 //按位与操作结果为01000000127.0.0.1:6379&gt; get destkey&quot;@&quot; 位图场景 1)不定期统计用户登录天数 key为当前用户id,value为bitmap，每一位相当于天数，登录则为1，反之为0 1234setbit zs 1 1 //第2天登录设为1setbit zs 90 1 //第91天登录设为1setbit zs 364 1 //第365天登录设为1bitcount zs -7 -1 //统计最后一周登录天数 2）不定期统计活跃用户数量 key为时间，value为bitmap,每一位相当于一个用户id， 12345setbit 20191001 0 1 //2019年10月1号 张三登录setbit 20191002 0 1 //2019年10月2号 张三登录setbit 20191002 1 1 //2019年10月2号 李四登录bitop or destkey 20191001 20191002 //2019年10月1号至10月2号登录人数bitcount destkey 0 -1 //统计2019年10月1号至10月2号登录人数 list常用命令:lpush、lrange、lpop、lindex、lset、lrem、linsert、llen、ltrim rpush、range、rpop、blpoplist是重复有序的，包含了栈、队列、数组、单播订阅的概念 hash常用命令:hset、hmset、hget、hmget、hvals、hgetall 应用场景:点赞、收藏、详情页 set常用命令：sadd、smembers、sinter、sinterstore、sunion、sdiff、srandmember、spop 123456sadd k9 1 2 3 4 5 srandmember k9 3 //随机取三个，不会重复srandmember k9 -3 //随机取三个，会重复srandmember k9 10 //只能取出5个srandmember k9 -10 //随机取10个，会重复spop k9 //随机取1个，并把这个值去除 可用于年会抽奖，一人一份的场景 set是去重无序的.应用场景：随机抽奖 sorted_set常用命令:zadd、zrange、zrevrange、zscore、zrank、zunionscore 应用场景：排行榜 排序之所以快是因为使用skip_list(跳跃表)实现的。skip_list是一个分层结构多级链表，最下层是原始链表，每个层级都是下一个层级的“高速跑道”.跳表具有如下性质： 1)由很多层结构组成 2)每一层都是一个有序链表 3)最底层的链表包含所有元素 4)如果一个元素出现在 i层，则它在i层之下的链表也都会出现 5)每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。 IO模式及零拷贝bio 阻塞 nio 非阻塞 实现方式：select,poll,epoll 多路复用，同步非阻塞 aio 异步非阻塞 进程连接数 io效率 消息传递 select 有限 采用轮询方式，遍历所有fd判断是否就绪 用户态、内核态切换 poll 基于链表，没有限制 采用轮询方式，遍历所有fd判断是否就绪 用户态、内核态切换 epoll 有限，但是上限很大 采用回调机制，返回就绪fd mmap内存共享空间 epoll详解： epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制。 核心API:epoll_create,epoll_ctl,epoll_wait epoll_create生成epoll实例并返回一个文件描述符即epoll句柄，epoll_ctl,epoll_wait均以此为核心。 epoll_ctl 将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改 epoll_wait 向用户进程返回处于ready状态下的文件描述符列表 采用回调机制，在执行add操作时，将文件描述符放到红黑树上，同时注册回调函数，内核在检测到某fd可读/写时会调用此回调函数，该回调函数将文件描述符放在就绪链表中。 零拷贝sendfile 零拷贝是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间而直接在内核空间中传输到网络的方式，减少cpu的占用和内存带宽。 1、发出sendfile系统调用，用户空间和内核空间上下文切换（第1次上下文切换） 2、通过DMA将磁盘文件中的内容拷贝到内核空间缓冲区（第1次拷贝：hard driver-&gt;kernel buffer） 3、DMA发出中断，CPU处理中断，将数据从内核缓冲区拷贝到socket缓冲区(第2次拷贝：kener buffer -&gt; socket buffer) 4、sendfile系统调用返回，内核空间到用户空间上下文切换(第2次上下文切换) 5、通过DMA将socket缓冲区中的数据传递到网卡(第3次拷贝：socket buffer -&gt;网卡) 3次上下文切换，3次拷贝。 1、调用read()，上下文切换到内核，DMA把磁盘数据复制到内核缓冲区 2、read()返回，上下文切换到用户空间，CPU把数据复制到用户的缓存空间 3、write()上下文切换到内核，CPU把数据复制到socket缓冲区 4、write()返回，上下文切换到用户进程 5、DMA把socket缓冲区数据复制到网卡 4次上下文切换，4次拷贝。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis进阶]]></title>
    <url>%2F2019%2F10%2F05%2Fredis%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[发布订阅 publish/subscribe 1发布一条消息，2开始订阅，此时不会收到刚刚发布的消息 3 再次发布消息 此时订阅端才会收到发布的消息。订阅后不能看到订阅之前发布的消息。 事务123multi //开启事务set k1 123exec //执行事务 布隆过滤器布隆过滤器是一个bitmap,集合元素通过几种不同的哈希函数生成的哈希值映射到bit位设为1。只要有一个哈希值对应的bit位为0时就会认为不存在此元素。 可以使用布隆过滤器预防穿透，但是布隆过滤器不会保证百分百准确同时也不支持删除。 redis缓存缓存：1不是全量数据2缓存应该存放热数据3数据可以丢4 追求极速 数据库：1全量数据2数据不能丢3追求速度+持久性 回收策略: noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）(做数据库时使用此策略) allkeys-lru: 尝试回收最久使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最久使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-lfu:从所有键中驱逐使用频率最少的键。 volatile-lfu:从所有配置了过期时间的键中驱逐使用频率最少的键。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 根据业务来选择使用哪种策略，一般使用lru及lfu策略。 过期: 如果没有到达过期时间，发生写操作，那么过期时间会被剔除 过期判断原理: 1如果key已经过期，那么当客户端尝试访问时，key会被发现并主动过期 2周期轮询判定，直到过期的key的百分比低于25%redis持久化RDBrdb持久化方式能够在指定时间间隔对数据进行快照，具有时点性,通过SAVE和BGSAVE对数据集进行保存。 SAVE命令会阻塞redis的服务进程，直到rdb文件创建完毕为止。只有在目的明确时才使用，如关机等。 BGSAVE命令则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。 工作原理： Redis 调用forks. 同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。 rdb只有一个dump.rdb文件，如需历史数据需要手动维护。 【管道】管道是阻塞的，会触发子进程。常规下linux进程间数据是隔离的。 使用系统调用:fork()会产生一个新的子进程，子进程只会开辟一个虚拟空间，而物理空间(内核)是和父进程共享的（指向同一个指针），只有当进程的数据发生变化时才会在物理空间复制一份新的数据并在此空间进行写操作。这利用了copy on write（写时复制）,只有在数据变化写入时才会发生复制。 AOF（Append-only file）每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。 工作原理： Redis 执行 fork() ，现在同时拥有父进程和子进程。 子进程开始将新 AOF 文件的内容写入到临时文件。 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。 现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。 丢失数据 恢复速度 RDB 会丢失一个时点的数据，相对较大 体积相对小，恢复速度快 AOF 丢失数据少 体积相对大，恢复速度慢 推荐使用AOF和RDB两种方式，配置文件修改属性aof-usr-rdb-preamble yes表示开启AOF、RDB混合模式。这种模式只会生成一个aof文件，aof文件包含rdb及增量指令。只有触发BGREWRITEAOF 时aof才会包含rdb.如下： 主从复制主备、主从、主主概念可参考https://www.cnblogs.com/tankblog/p/11190598.html 主从和主备的区别是除了同步数据之外还得干活，对外提供读的操作。 REPLICAOF hostname port 当前服务器作为指定服务器的副本 REPLICAOF NO ONE 设置当前服务器为主服务器 sentinel (哨兵)sentinel是解决redis高可用的方案,可以监视多个主服务器及主服务器的从服务器，可以在主服务器挂掉的时候指定新的主服务器。 1234567//创建sentinel配置文件port 26379 //指定端口号//指定监听主服务器(本地6279端口)，2代表当有2个哨兵认为master失效时，master才算失效sentinel monitor mymaster localhost 6379 2 //启动哨兵redis-cli sentinel.conf --sentinel 如果主挂了哨兵会重新选一个主，然后让其他从跟随,哨兵(通过发布订阅)知道当前redis会有其他几个哨兵。 分区/分片redis集群中内置了 16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽. 使用哈希槽的好处就在于可以方便的添加或移除节点。 当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了； 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了； 扩展redis存在问题：单机故障，容量有量，压力 AKFAKF扩展立方、分别从XYZ轴展开，可以解决redis存在的问题 X轴:主从复制、高可用，通过克隆进行扩展 Y轴:业务拆分，通过拆分不同的东西进行扩展 Z轴:地域性划分，通过拆分相似的东西进行扩展 脑裂脑裂:高可用集群故障，由一个整体拆分成两部分都可以对外提供服务，导致数据不一致。搭建集群时设定的数量是奇数，可以防止脑裂。 例：AB两机房由于网络中断，分别对外提供服务。则对A进行插入操作，从B读取不到数据。如果A中的机器数量占整个集群的一半以上，那么B会自动宕机，由A来对外提供服务。 CAP（分布式的三大特性）Consistency(一致性): 读取的数据是写入的数据。 Availability(可用性):只要收到用户的请求，服务器就必须给出回应。 Partition tolerance(分区容忍性):必然存在网络故障断开的风险，这个网络断开的专业场景成为网络分区。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 CAP 原则指的是，这三个要素最多只能同时实现两点，实际只能保证CP、AP。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。 一致性哈希算法将哈希值空间组织成一个虚拟的圆环，将每台机器通过哈希算法映射到圆环上(物理节点)，将数据通过哈希算法映射到圆环，按顺时针找到下一个物理节点存储此数据。但不能保证每台机器数据分布均匀，可能会集中在某台机器上。这时可为每台机器虚拟出几个节点，这样会缓解数据倾倒。 面试常问击穿一个key或少量的key过期造成并发访问数据库.可以在客户端异步访问redis,第一个访问到的调用setnx(key timeout)从数据库取值,其他客户端访问如果没有得到值可更改setnx(key)的过期时间。 穿透查询数据是系统根本不存在的数据(黑客攻击)，可以使用布隆过滤器 雪崩大量的key同时失效.可以均匀设置过期时间，可以参考击穿方案使用分布式锁。 vim命令小技巧: .,$y 表示复制当前行到末行 Gp 从最后一行开始粘贴 工欲善其事，必先利其器。要学会利用官方网站、github。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程1]]></title>
    <url>%2F2019%2F09%2F26%2F%E7%BA%BF%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[创建方式 1)继承Thread类 2)实现Runnable接口 12345678910111213141516171819202122232425public class TestThread &#123; public static void main(String[] args) &#123; T1 t1 = new T1(); t1.setName(&quot;t1,继承Thread类&quot;); t1.start();//启动线程1 T2 t2 = new T2(); Thread thread = new Thread(t2); t1.setName(&quot;t2,实现Runnable接口&quot;); thread.start();//启动线程2 &#125;&#125;class T1 extends Thread&#123; @Override public void run()&#123; System.out.println(&quot;当前线程名称:&quot;+Thread.currentThread().getName()); &#125;&#125;class T2 implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;当前线程名称:&quot;+Thread.currentThread().getName()); &#125;&#125; 线程状态 New Runnable,细分为ready和running,调用start()方法进入ready,获得使用权后进入running Block,分为等待阻塞，超时等待阻塞及其他阻塞。调用sleep,wait等方法会造成阻塞 Teminated 常用方法join:暂停当前线程，执行join线程，等join线程执行完毕继续执行当前线程 123456789101112131415161718192021public class TestJoinThread &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); t1.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;主线程执行&quot;); &#125;&#125;class T1 extends Thread&#123; @Override public void run()&#123; for (int i=0;i&lt;100;i++)&#123; System.out.println(&quot;t1,第&quot;+i+&quot;次开始执行&quot;); &#125; &#125; //执行结果t1执行100次之后输出主线程执行，主线程要等到t1线程执行结束再执行 join方法可以使线程按自己定义的顺序执行 sleep和wait方法的区别： sleep属于Thread类的静态方法；wait属于Object类的方法 sleep不释放锁，使用interrupt方法打断；wait释放锁，会造成阻塞，使用notify方法唤醒 同步多个线程抢占同一资源需要加锁即synchronized，保证原子性。 锁升级：偏向锁、轻量级锁、重量级锁 有一个线程时会使用偏向锁，有线程竞争后会升级为轻量级锁，未获得锁的线程会自旋，当达到设定的自旋次数后依旧没有获得锁，会升级为重量级锁。 线程少、方法执行时间短的时候会使用轻量级锁，会占用cpu资源 线程多，执行时间长会使用重量级锁，不占用cpu资源，但会增加用户态和内核态的切换次数，系统开销比较大 生产者消费者案例篮子存放牛奶，生产者把牛奶放入篮子，消费者从篮子取出牛奶 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class TestSync &#123; public static void main(String[] args) &#123; Basket b = new Basket(); new Thread(new Producer(b)).start(); new Thread(new Consumer(b)).start(); &#125;&#125;//牛奶class Milk&#123; int id; Milk(int id)&#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;Milk:&quot;+id; &#125;&#125;/** * 篮子，篮子存放8盒牛奶，有放入和取出方法 * 涉及到同步，等待，唤醒, * 第1，2处使用while不使用if是因为会反复确认条件是否成立再向下执行 */class Basket&#123; Milk[] milks = new Milk[8]; int index = 0; public synchronized void push(Milk m)&#123; while(index == milks.length)&#123; //第1处 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); System.out.println(&quot;生产了:&quot;+index); milks[index] = m; index++; &#125; public synchronized Milk pop()&#123; while(index == 0)&#123; //第2处 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); index--; System.out.println(&quot;消费了:&quot;+index); return milks[index]; &#125;&#125;//生产者，生产牛奶放入篮子class Producer implements Runnable&#123; Basket b = new Basket(); Producer(Basket basket)&#123; this.b = basket; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; b.push(new Milk(i)); &#125; &#125;&#125;//消费者，从篮子里拿出牛奶class Consumer implements Runnable&#123; Basket b = new Basket(); Consumer(Basket basket)&#123; this.b = basket; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; b.pop(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
