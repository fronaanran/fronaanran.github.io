<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis基础]]></title>
    <url>%2F2019%2F10%2F05%2Fredis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本介绍Redis 是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件，支持多种类型的数据结构,是单进程，单实例。 memcache和redis对比： memcache &lt;key,value&gt; value没有类型的概念 redis &lt;key,value&gt; value支持多种类型的多种方法。 例：“person,{name:’小明’,age:18}”当客户端需要获取value中的age时，memcache会返回所有value值，让客户端去遍历所需要的值 ，而redis会直接返回value相对应的age。本质上解耦，体现计算向数据移动。 数据库排名网站 ：https://db-engines.com/en/ redis中文网站：http:redis.cn redis官方网站: https://redis.io/ 基本语法string读取(范围/批量):get k1 / getrange k1 3 -1 / mget k1 k2 赋值(范围/批量):set k1 hello / getrange k1 2 -1 / mset k2 222 k3 333 set key nx 不存在时赋值，在分步式锁时使用​ set key xx 存在时赋值 append,strlength等等字符串基本语法 数值：递增)incr k1 / incrby k1 22 递减)decr k1 / decrby k1 2 redis是二进制安全的，需要和客户端沟通好编码类型. bitmap(位图):setbit,getbit ,bitcount,bitop 0(第0个字节) 1(第1个字节) 00000000（8位） 00000000(8位) 123456789101112131415161718192021127.0.0.1:6379&gt; setbit k1 1 1 //第0个字节第2位设置为1 即01000000127.0.0.1:6379&gt; get k1&quot;@&quot;127.0.0.1:6379&gt; setbit k1 10 1 //第2个字节第3位设置为1 即01000000127.0.0.1:6379&gt; get k1&quot;@ &quot;127.0.0.1:6379&gt; bitcount k1 0 0 //k1第0个字节有几个1(integer) 1127.0.0.1:6379&gt; bitcount k1 0 1 //k1第0至1个字节有几个1(integer) 2127.0.0.1:6379&gt; setbit k2 1 1127.0.0.1:6379&gt; setbit k2 7 1127.0.0.1:6379&gt; get k2 //01000001&quot;A&quot;127.0.0.1:6379&gt; setbit k3 1 1127.0.0.1:6379&gt; setbit k3 6 1127.0.0.1:6379&gt; get k3 //01000010&quot;B&quot;127.0.0.1:6379&gt; bitop and destkey k2 k3 //按位与操作结果为01000000127.0.0.1:6379&gt; get destkey&quot;@&quot; 位图场景 1)不定期统计用户登录天数 key为当前用户id,value为bitmap，每一位相当于天数，登录则为1，反之为0 1234setbit zs 1 1 //第2天登录设为1setbit zs 90 1 //第91天登录设为1setbit zs 364 1 //第365天登录设为1bitcount zs -7 -1 //统计最后一周登录天数 2）不定期统计活跃用户数量 key为时间，value为bitmap,每一位相当于一个用户id， 12345setbit 20191001 0 1 //2019年10月1号 张三登录setbit 20191002 0 1 //2019年10月2号 张三登录setbit 20191002 1 1 //2019年10月2号 李四登录bitop or destkey 20191001 20191002 //2019年10月1号至10月2号登录人数bitcount destkey 0 -1 //统计2019年10月1号至10月2号登录人数 list常用命令:lpush、lrange、lpop、lindex、lset、lrem、linsert、llen、ltrim rpush、range、rpop、blpoplist是重复有序的，包含了栈、队列、数组、单播订阅的概念 hash常用命令:hset、hmset、hget、hmget、hvals、hgetall 应用场景:点赞、收藏、详情页 set常用命令：sadd、smembers、sinter、sinterstore、sunion、sdiff、srandmember、spop 123456sadd k9 1 2 3 4 5 srandmember k9 3 //随机取三个，不会重复srandmember k9 -3 //随机取三个，会重复srandmember k9 10 //只能取出5个srandmember k9 -10 //随机取10个，会重复spop k9 //随机取1个，并把这个值去除 可用于年会抽奖，一人一份的场景 set是去重无序的.应用场景：随机抽奖 sorted_set常用命令:zadd、zrange、zrevrange、zscore、zrank、zunionscore 应用场景：排行榜 排序之所以快是因为使用skip_list(跳跃表)实现的。skip_list是一个分层结构多级链表，最下层是原始链表，每个层级都是下一个层级的“高速跑道”.跳表具有如下性质： 1)由很多层结构组成 2)每一层都是一个有序链表 3)最底层的链表包含所有元素 4)如果一个元素出现在 i层，则它在i层之下的链表也都会出现 5)每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。 IO模式及零拷贝bio 阻塞 nio 非阻塞 实现方式：select,poll,epoll 多路复用，同步非阻塞 aio 异步非阻塞 进程连接数 io效率 消息传递 select 有限 采用轮询方式，遍历所有fd判断是否就绪 用户态、内核态切换 poll 基于链表，没有限制 采用轮询方式，遍历所有fd判断是否就绪 用户态、内核态切换 epoll 有限，但是上限很大 采用回调机制，返回就绪fd mmap内存共享空间 epoll详解： epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制。 核心API:epoll_create,epoll_ctl,epoll_wait epoll_create生成epoll实例并返回一个文件描述符即epoll句柄，epoll_ctl,epoll_wait均以此为核心。 epoll_ctl 将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改 epoll_wait 向用户进程返回处于ready状态下的文件描述符列表 采用回调机制，在执行add操作时，将文件描述符放到红黑树上，同时注册回调函数，内核在检测到某fd可读/写时会调用此回调函数，该回调函数将文件描述符放在就绪链表中。 零拷贝sendfile 零拷贝是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间而直接在内核空间中传输到网络的方式，减少cpu的占用和内存带宽。 1、发出sendfile系统调用，用户空间和内核空间上下文切换（第1次上下文切换） 2、通过DMA将磁盘文件中的内容拷贝到内核空间缓冲区（第1次拷贝：hard driver-&gt;kernel buffer） 3、DMA发出中断，CPU处理中断，将数据从内核缓冲区拷贝到socket缓冲区(第2次拷贝：kener buffer -&gt; socket buffer) 4、sendfile系统调用返回，内核空间到用户空间上下文切换(第2次上下文切换) 5、通过DMA将socket缓冲区中的数据传递到网卡(第3次拷贝：socket buffer -&gt;网卡) 3次上下文切换，3次拷贝。 1、调用read()，上下文切换到内核，DMA把磁盘数据复制到内核缓冲区 2、read()返回，上下文切换到用户空间，CPU把数据复制到用户的缓存空间 3、write()上下文切换到内核，CPU把数据复制到socket缓冲区 4、write()返回，上下文切换到用户进程 5、DMA把socket缓冲区数据复制到网卡 4次上下文切换，4次拷贝。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis进阶]]></title>
    <url>%2F2019%2F10%2F05%2Fredis%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[发布订阅 publish/subscribe 1发布一条消息，2开始订阅，此时不会收到刚刚发布的消息 3 再次发布消息 此时订阅端才会收到发布的消息。订阅后不能看到订阅之前发布的消息。 事务123multi //开启事务set k1 123exec //执行事务 布隆过滤器布隆过滤器是一个bitmap,集合元素通过几种不同的哈希函数生成的哈希值映射到bit位设为1。只要有一个哈希值对应的bit位为0时就会认为不存在此元素。 可以使用布隆过滤器预防穿透，但是布隆过滤器不会保证百分百准确同时也不支持删除。 redis缓存缓存：1不是全量数据2缓存应该存放热数据3数据可以丢4 追求极速 数据库：1全量数据2数据不能丢3追求速度+持久性 回收策略: noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）(做数据库时使用此策略) allkeys-lru: 尝试回收最久使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最久使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-lfu:从所有键中驱逐使用频率最少的键。 volatile-lfu:从所有配置了过期时间的键中驱逐使用频率最少的键。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 根据业务来选择使用哪种策略，一般使用lru及lfu策略。 过期: 如果没有到达过期时间，发生写操作，那么过期时间会被剔除 过期判断原理: 1如果key已经过期，那么当客户端尝试访问时，key会被发现并主动过期 2周期轮询判定，直到过期的key的百分比低于25%redis持久化RDBrdb持久化方式能够在指定时间间隔对数据进行快照，具有时点性,通过SAVE和BGSAVE对数据集进行保存。 SAVE命令会阻塞redis的服务进程，直到rdb文件创建完毕为止。只有在目的明确时才使用，如关机等。 BGSAVE命令则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。 工作原理： Redis 调用forks. 同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。 rdb只有一个dump.rdb文件，如需历史数据需要手动维护。 【管道】管道是阻塞的，会触发子进程。常规下linux进程间数据是隔离的。 使用系统调用:fork()会产生一个新的子进程，子进程只会开辟一个虚拟空间，而物理空间(内核)是和父进程共享的（指向同一个指针），只有当进程的数据发生变化时才会在物理空间复制一份新的数据并在此空间进行写操作。这利用了copy on write（写时复制）,只有在数据变化写入时才会发生复制。 AOF（Append-only file）每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。 工作原理： Redis 执行 fork() ，现在同时拥有父进程和子进程。 子进程开始将新 AOF 文件的内容写入到临时文件。 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。 现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。 丢失数据 恢复速度 RDB 会丢失一个时点的数据，相对较大 体积相对小，恢复速度快 AOF 丢失数据少 体积相对大，恢复速度慢 推荐使用AOF和RDB两种方式，配置文件修改属性aof-usr-rdb-preamble yes表示开启AOF、RDB混合模式。这种模式只会生成一个aof文件，aof文件包含rdb及增量指令。只有触发BGREWRITEAOF 时aof才会包含rdb.如下： 主从复制主备、主从、主主概念可参考https://www.cnblogs.com/tankblog/p/11190598.html 主从和主备的区别是除了同步数据之外还得干活，对外提供读的操作。 REPLICAOF hostname port 当前服务器作为指定服务器的副本 REPLICAOF NO ONE 设置当前服务器为主服务器 sentinel (哨兵)sentinel是解决redis高可用的方案,可以监视多个主服务器及主服务器的从服务器，可以在主服务器挂掉的时候指定新的主服务器。 1234567//创建sentinel配置文件port 26379 //指定端口号//指定监听主服务器(本地6279端口)，2代表当有2个哨兵认为master失效时，master才算失效sentinel monitor mymaster localhost 6379 2 //启动哨兵redis-cli sentinel.conf --sentinel 如果主挂了哨兵会重新选一个主，然后让其他从跟随,哨兵(通过发布订阅)知道当前redis会有其他几个哨兵。 分区/分片redis集群中内置了 16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽. 使用哈希槽的好处就在于可以方便的添加或移除节点。 当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了； 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了； 扩展redis存在问题：单机故障，容量有量，压力 AKFAKF扩展立方、分别从XYZ轴展开，可以解决redis存在的问题 X轴:主从复制、高可用，通过克隆进行扩展 Y轴:业务拆分，通过拆分不同的东西进行扩展 Z轴:地域性划分，通过拆分相似的东西进行扩展 脑裂脑裂:高可用集群故障，由一个整体拆分成两部分都可以对外提供服务，导致数据不一致。搭建集群时设定的数量是奇数，可以防止脑裂。 例：AB两机房由于网络中断，分别对外提供服务。则对A进行插入操作，从B读取不到数据。如果A中的机器数量占整个集群的一半以上，那么B会自动宕机，由A来对外提供服务。 CAP（分布式的三大特性）Consistency(一致性): 读取的数据是写入的数据。 Availability(可用性):只要收到用户的请求，服务器就必须给出回应。 Partition tolerance(分区容忍性):必然存在网络故障断开的风险，这个网络断开的专业场景成为网络分区。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 CAP 原则指的是，这三个要素最多只能同时实现两点，实际只能保证CP、AP。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。 一致性哈希算法将哈希值空间组织成一个虚拟的圆环，将每台机器通过哈希算法映射到圆环上(物理节点)，将数据通过哈希算法映射到圆环，按顺时针找到下一个物理节点存储此数据。但不能保证每台机器数据分布均匀，可能会集中在某台机器上。这时可为每台机器虚拟出几个节点，这样会缓解数据倾倒。 面试常问击穿一个key或少量的key过期造成并发访问数据库.可以在客户端异步访问redis,第一个访问到的调用setnx(key timeout)从数据库取值,其他客户端访问如果没有得到值可更改setnx(key)的过期时间。 穿透查询数据是系统根本不存在的数据(黑客攻击)，可以使用布隆过滤器 雪崩大量的key同时失效.可以均匀设置过期时间，可以参考击穿方案使用分布式锁。 vim命令小技巧: .,$y 表示复制当前行到末行 Gp 从最后一行开始粘贴 工欲善其事，必先利其器。要学会利用官方网站、github。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程1]]></title>
    <url>%2F2019%2F09%2F26%2F%E7%BA%BF%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[创建方式 1)继承Thread类 2)实现Runnable接口 12345678910111213141516171819202122232425public class TestThread &#123; public static void main(String[] args) &#123; T1 t1 = new T1(); t1.setName(&quot;t1,继承Thread类&quot;); t1.start();//启动线程1 T2 t2 = new T2(); Thread thread = new Thread(t2); t1.setName(&quot;t2,实现Runnable接口&quot;); thread.start();//启动线程2 &#125;&#125;class T1 extends Thread&#123; @Override public void run()&#123; System.out.println(&quot;当前线程名称:&quot;+Thread.currentThread().getName()); &#125;&#125;class T2 implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;当前线程名称:&quot;+Thread.currentThread().getName()); &#125;&#125; 线程状态 New Runnable,细分为ready和running,调用start()方法进入ready,获得使用权后进入running Block,分为等待阻塞，超时等待阻塞及其他阻塞。调用sleep,wait等方法会造成阻塞 Teminated 常用方法join:暂停当前线程，执行join线程，等join线程执行完毕继续执行当前线程 123456789101112131415161718192021public class TestJoinThread &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); t1.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;主线程执行&quot;); &#125;&#125;class T1 extends Thread&#123; @Override public void run()&#123; for (int i=0;i&lt;100;i++)&#123; System.out.println(&quot;t1,第&quot;+i+&quot;次开始执行&quot;); &#125; &#125; //执行结果t1执行100次之后输出主线程执行，主线程要等到t1线程执行结束再执行 join方法可以使线程按自己定义的顺序执行 sleep和wait方法的区别： sleep属于Thread类的静态方法；wait属于Object类的方法 sleep不释放锁，使用interrupt方法打断；wait释放锁，会造成阻塞，使用notify方法唤醒 同步多个线程抢占同一资源需要加锁即synchronized，保证原子性。 锁升级：偏向锁、轻量级锁、重量级锁 有一个线程时会使用偏向锁，有线程竞争后会升级为轻量级锁，未获得锁的线程会自旋，当达到设定的自旋次数后依旧没有获得锁，会升级为重量级锁。 线程少、方法执行时间短的时候会使用轻量级锁，会占用cpu资源 线程多，执行时间长会使用重量级锁，不占用cpu资源，但会增加用户态和内核态的切换次数，系统开销比较大 生产者消费者案例篮子存放牛奶，生产者把牛奶放入篮子，消费者从篮子取出牛奶 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class TestSync &#123; public static void main(String[] args) &#123; Basket b = new Basket(); new Thread(new Producer(b)).start(); new Thread(new Consumer(b)).start(); &#125;&#125;//牛奶class Milk&#123; int id; Milk(int id)&#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;Milk:&quot;+id; &#125;&#125;/** * 篮子，篮子存放8盒牛奶，有放入和取出方法 * 涉及到同步，等待，唤醒, * 第1，2处使用while不使用if是因为会反复确认条件是否成立再向下执行 */class Basket&#123; Milk[] milks = new Milk[8]; int index = 0; public synchronized void push(Milk m)&#123; while(index == milks.length)&#123; //第1处 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); System.out.println(&quot;生产了:&quot;+index); milks[index] = m; index++; &#125; public synchronized Milk pop()&#123; while(index == 0)&#123; //第2处 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); index--; System.out.println(&quot;消费了:&quot;+index); return milks[index]; &#125;&#125;//生产者，生产牛奶放入篮子class Producer implements Runnable&#123; Basket b = new Basket(); Producer(Basket basket)&#123; this.b = basket; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; b.push(new Milk(i)); &#125; &#125;&#125;//消费者，从篮子里拿出牛奶class Consumer implements Runnable&#123; Basket b = new Basket(); Consumer(Basket basket)&#123; this.b = basket; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; b.pop(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
