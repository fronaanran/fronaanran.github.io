<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql优化]]></title>
    <url>%2F2020%2F01%2F10%2Fmysql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[[TOC] mysql优化监控1234set profiling =1;show PROFILES;//列出所有语句的执行时间，包含query_id,duration,queryshow profile all;//默认显示最后一条语句的各个阶段的执行时间show profile for query query_id;//显示指定语句的各个阶段的执行时间 也使用explain执行计划来查看 数据类型优化 更小的字节数更好 ，如能用tinyint便不用int 选用适当的数据类型，比如能存整型便不用字符串，地址存放可以使用整型替换字符串，Inet_ATON(“”) 使用日期类型来存储日期不要使用字符串 优化细节 尽量在where,order by,grouby 之后使用索引 select的字段值只包含需要显示的值，不能写* 小知识点 char类型查询时会自动删除末尾空格，最大长度为255，是定长的，而varchar是变长的。 整型(TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT)分别使用(8,16,24,32,64)位存储空间。例int(5)存储长度是按int类型来存储的即占4个字节，存储范围为(-2^31-2^31-1)与指定的长度无关。 utf8只能存储两个字节，因为有的中文不止两个字节，所以会出现乱码情况，推荐使用utfmb4 数据库拆分分为水平拆分(按数据)、垂直拆分(按业务)，垂直拆分是根据业务把不同的表拆分到不同的数据库，而水平拆分是把同一张表不同的数据拆分到不同的数据库 最左前缀与where后面的条件顺序无关，只与定义的字段值有关，因为优化器在优化的时候会进行匹配 比如:idx_name_age_sex，姓名、年龄、性别做为一个组合索引，查询时使用 where name=’’ and sex=”” and age=””，依旧会使用组合索引查询， where name=”” and sex=””,此时sex不满足最左匹配原则，所以sex使用普通列查询 where name=”” and age&gt;10 and sex=””，此时只有name和age作为组合索引，而sex做为普通列查询，因为age是范围查找，范围查找之后的条件如果有索引，索引会被当做普通列，但是当范围结果值过小的时候依旧会使用索引值 where name=”” and age&gt;80 and sex=“”,当age范围的结果值过小时可能依旧会使用索引值 最左前缀是和组合索引相关联的。 order by使用哪种排序方式是与where 条件相关的，如果where 使用索引等值查询，order by字段只包含索引字段，则使用索引排序，如果orderby字段包含非索引字段则使用filesort。如果where使用索引范围查询，order by的值可能会使用filesort. select * from t1 group by id,当按id分组时,select 字段可以不用分组 使用大数据量查找时尽量使用limit，如果是单一张表那么会一行一行扫描数据到指定limit值，第二种使用覆盖索引方式快。 1）select * from rental limit 10000,52）select * from rental a join (select rental_id from rental order by rental_id limit 10000,5) b on a.rental_id=b.rental_id 自定义变量,定义set @变量名:=值 例:set @temp:=2 set @min_actor :=(select min(actor_id) from actor) //查询10条数据并按1-10排列，可以使用自定义变量来完成 set @rownum:=0;select actor_id,@rownum:=@rownum+1 from actor limit 10; 分区表 按分区类型可分为:范围分区、列表分区、列分区、hash分区、key分区和子分区。 列表分区定义如下： 123456PARTITION BY LIST(store_id) ( PARTITION pNorth VALUES IN (3,5,6,9,17), PARTITION pEast VALUES IN (1,2,10,11,19,20), PARTITION pWest VALUES IN (4,12,13,14,18), PARTITION pCentral VALUES IN (7,8,15,16)); 详情可参考:mysql官网 join算法 前缀索引 当索引列为很长的字符，会使索引查询效率又大又慢，这时可以使用字符串的前几个字符作为索引(即前缀索引)。 前缀索引需选择足够长的前缀以保证较高的选择性，同时又不能太长(造成空间浪费) 索引的选择性 索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 count(distinct left(content,7))/count(*) 1alter table article add index idx_content( content(7) )//设置前缀索引 mysql中无法使用前缀索引进行order by 和group by ,也无法用于覆盖索引 联合索引的B+树形式 非叶子节点存储的是联合索引key的键值对，叶子节点存储的是联合索引key的键值对+主键索引]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2020%2F01%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 选择排序123456789101112131415161718192021public static void main(String[] args) &#123; sort(new int[]&#123;8,6,4,2,9,3,1&#125;); &#125; static void sort(int[] array)&#123; int[] arr=array; for(int i=0;i&lt;arr.length-1;i++)&#123; int minPosition =i; //默认第i个位置是最小值 for(int j=i+1;j&lt;arr.length;j++)&#123; minPosition=arr[j]&lt;arr[minPosition]?j:minPosition; &#125; //每一轮循环后，得出最小值，跟i交换 swap(arr,i,minPosition); &#125; //输出排序后的数组 Stream.of(arr).forEach(x-&gt; System.out.print(Arrays.toString(x))); &#125; public static void swap(int[] arr,int i,int j)&#123; int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; &#125; 冒泡排序1234567891011121314151617public static void main(String[] args) &#123; int[] arr =&#123;4,3,7,6,8,9,2,1,11&#125;; sort(arr); &#125; static void sort(int[] arr)&#123; for(int i=arr.length-1;i&gt;0;i--) for(int j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; for (int i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+" "); &#125; &#125; 插入排序12345678910111213141516171819public static void main(String[] args) &#123; sort(); &#125; static void sort()&#123; int[] arr=&#123;5,6,7,3,2,1&#125;; for(int i=1;i&lt;arr.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(arr[j]&lt;arr[j-1])&#123; int temp = arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; &#125; &#125; &#125; for (int i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+" "); &#125; &#125; 各种排序算法总结]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql之索引、事务、执行计划、日志、锁]]></title>
    <url>%2F2020%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%B4%A2%E5%BC%95%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[[TOC] mysql架构图 mysql执行顺序 select 列名 from 表1 left join 表2 on 关联条件 where 筛选条件 group by 分组字段 order by 排序字段 1) 表1和表2 按照on关联条件筛选值 2) left join 添加外部行，把左表在第二步中过滤的条件添加进来 3) where 对上面的结果进行where 筛选 4) group by 对上一步的结果进行分组 5) select 对上一步的结果筛选出所需要的列 6) order by 按照指定顺序排列 select 列名 from 表1 left join 表2 on 关联条件 group by 分组字段 having 筛选条件 order by 排序字段 1) 表1和表2 按照on关联条件筛选值 2) left join 添加外部行，把左表在第二步中过滤的条件添加进来 3) group by 对上一步的结果进行分组 4) having 对上面的结果按条件筛选 5) select 对上一步的结果筛选出所需要的列 6) order by 按照指定顺序排列 数据库三范式三范式最终的目的是解决数据冗余 第一范式：所有字段值都是不可分解的原子值即列不可分。例：地址字段可以拆分为省、市、县，拆分之后即满足第一范式 第二范式：确保表中的每列都和主键相关。例：学生表字段包含教师编号、教师姓名，此处教师姓名跟学生表主键没有依赖关系，所以不满足第二范式。可以把学生编号及教师编号组成一个中间表 第三范式：要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。第三范式是第二范式的子集，即满足第三范式，必须满足第二范式。 事务四个特性：原子性、一致性、隔离性、持久性原子性：表示不可分割，要么全部成功，要么全部失败 一致性：保证数据的一致性，当经过N个操作之后，数据的状态不会改变。保证数据不会发生错乱。 隔离性：各个事务之间操作不会产生影响。 持久性：数据会持久化到存储介质中，不会因为程序的关闭而导致数据丢失。 所的有特性 都是为了保证数据的一致性。事务一致性是通过原子性、隔离性、持久化来保证的。 隔离级别隔离级别包含读未提交、读已提交、可重复读、序列化 读未提交,在未commit之前，其他窗口能读取到修改的数据，会产生脏读。 读已提交，在未commit之前，其他窗口不能读取到修改的数据，此时commit，其他窗口可以读取到修改的数据。其他窗口在同一事务之间，前后做同样的操作会查询出不同的结果，即产生不可重复读。 可重复读，插入一条数据，未commit,其他窗口不能查询到此数据。commit,其他窗口同时插入此条数据会提示主键重复等异常，此时即产生幻读。 隔离级别 异常 异常 异常 read uncommit(读未提交) 脏读 不可重复读 幻读 read commit(读已提交) 不可重复读 幻读 repeatable commit(可重复读)默认隔离级别 幻读 serialize(序列化) 不可重复读是在查询时产生的，幻读是在插入或删除时产生的。 查看当前数据库是否设置自动提交命令:select @@autocommit; 1代表开启自动提交2未开启 set autocommit=0;//设置未开启 索引 局部性原理 当一个数据被用到，其附件的数据通常也会被马上使用。 时间局部性：如果某个数据被访问到，那么这个数据可能会被多次访问 空间局部性：如果某个位置的数据被访问，那么它相邻的数据很有可能被访问。 磁盘预读 预读的长度一般为页(page)的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页(在许多操作系统中，页得大小通常为4k) 例：要查找一个字节的数据，磁盘会把这个字节对应的页预读出来。即现在不需要的数据也读取了，这样以后用时就不用再读取，当一个数据用到时，大多数情况下，它周围的数据也会被用到。 索引采用的数据结构是B+树(以下是针对InnoDB来阐述) B树和B+树对比:B树：1)每个节点都有key和data,而每个页存储的空间是有限的，如果data比较大会导致每个节点存储的key数量变少 ​ 2)当存储的数据量很大的时候会导致深度较大，增大查询时磁盘的IO次数，影响查询性能 B+树:1)非叶子节点存储key,叶子节点存储key和数据。降低了树的高度，数据范围变为多个区间，区间越多，数据检索越快。 ​ 2)B+树有两个头指针，一个指向根节点，一个指向叶子节点。叶子节点之间是一种链式环结构。因此可以对B+树进行两种查找运算:一种是对于主键范围查找和分页查找，另一种是从根节点开始，进行随机查找。 主键索引，非叶子节点存储key和数据 非主键索引，叶子节点存储key和主键,查找时需要先查找非主键索引再通过主键索引查找对应记录。此时称为回表，会遍历两次B+树 MyISAM，非叶子节点存储key和地址值，然后通过地址值去数据文件查找相应数据。 索引的分类 主键索引主键最好设置成递增，因为这样索引文件会直接从尾部追加数据，防止产生页分裂和页合并的情况。进而防止出现IO性能低下，磁盘空间浪费的情况。 唯一索引 普通索引普通索引会遍历两次B+树，出现回表。当使用普通索引查询主键的时候只会遍历一次B+树，此时称为覆盖索引。 例:select id from emp where ename=’’; 全文索引 组合索引多个字段组成一个索引，查询时根据最左匹配原则， 例:有name_age索引，条件如果是根据age查，不符合最左匹配原则，不使用这个索引 例:有name，age两个字段，会根据name,age条件查询也会根据age查询,还会根据name查询，此时需要建立name_age索引及age索引 索引下推执行 select * from emp where name like ‘张%’ and age &gt; 10 语句会有两种情况 根据(name_age)组合索引查询所有满足以”张”开头的索引，然后回表查询出相应的全行数据，再筛选出年龄&gt;10的数据 根据(name_age)组合索引查询所有满足以”张”开头的索引，然后筛选年龄&gt;10的数据，再回表查询全行数据 第2种方式需要回表查询的全行数据比较少，这就是mysql的索引下推 存储引擎(MyISAM、InnoDB)聚簇索引:数据和索引存放在同一个文件。InnoDB .frm 存放表结构 .ibd:存放数据和索引信息 非聚簇索引:数据和索引存放在不同的文件。MyISAM .frm:存放表结构 .myi存放索引信息 .myd存放数据信息 日志bin log:服务端级别的日志 bin log记录语句的原始逻辑，并采用追加写的方式不会覆盖之前的日志信息 redo log:存储引擎级别的日志 redo log是为了实现事务的持久性。当数据修改时，会将记录写到redolog中并更新内存同时会在合适的时机将记录操作到磁盘中，redolog是固定大小的，是循环写的过程。即使数据库发生异常重启，之前的记录也不会丢失。 undo log:存储引擎级别的日志 undo log是为了实现事务的原子性。在操作数据之前，先将数据备份到一个地方(undolog)，然后进行数据的修改。如果出现错误或执行回滚语句，系统可以利用undo log中的备份将数据恢复到事务开始之前的状态 mysql的锁机制MyISAM只支持表级锁，InnoDB运行表级锁及行级锁，默认行级锁。 表级锁:开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行级锁:开销大，加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 MyISAMMyISAM的表级锁有两种模式：表共享读锁、表独占写锁 session1 session2 lock table mylock read //获得表的read锁 select * from mylock //可以查出数据 select * from test //不能查出其他表的数据 select * from mylock //可以查出数据 select * from test //可以查出数据 insert into mylock (id,value) values(6,”e”)//报错不能插入数据 insert into mylock (id,value) values(6,”e”)//阻塞，等待表锁释放后才能插入数据 unlock tables;//释放锁 数据插入成功 对表加读锁，本窗口只能对本表进行读操作，不能进行其他操作。其他窗口可以对本表及其他表进行读操作，可以进行更新操作，但是需要等待锁释放后才能操作成功。 MyISAM的并发插入问题：MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行 session1 session2 lock table mylock read local //获得表的read锁 只能对本表进行查询操作，不能做更新操作不能对其他表对操作； insert into mylock(8,”g”) //可以对本表进行任何操作可以对其他表进行任何操作 select * from mylock //此时session2插入的8是查不出来的即其他窗口对本表做更新操作，本表是查不出来的，只会显示加锁时的那些数据 unlock tables; 会查出最新的数据 session1 session2 lock table mylock write;//获得表的写锁 select * from myloc;insert into mylock values(7,”f”);//可以对表进行任何操作 select * from myloc;等待锁释放,对本表进行任何操作都会阻塞，其他表可以进行操作。 unlock tables;//释放锁 数据被执行 对表加写锁，本窗口可以进行任何操作，其他窗口对本表做任何操作都会造成阻塞，直到锁释放后才会执行。 InnoDB共享锁和排他锁 共享锁又称读锁，多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。设置共享锁：SELECT … LOCK IN SHARE MODE;排他锁又称写锁，一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。设置排他锁：SELECT … FOR UPDATE; update,delete,insert都会自动给涉及到的数据加上排他锁 InnoDB行锁是通过给索引上的索引项加锁而不是针对行记录加锁来实现的,只有通过索引条件检索数据，InnoDB才使用行级锁。使用主键索引、唯一索引条件时会使用行索，但当使用普通索引时，需要看此索引项的列值重复率，如果重复率高那么会使用表锁。 关于行级锁、间隙锁可参考此链接 执行计划使用 explain关键字来查询，explain select * from emp; 执行计划包含的信息 Column Meaning id the select identifier(选择标识符) select_type the select type(表示查询的类型) table the table for the output row(输出结果集的表) partitions the matching partitions(匹配的分区) type the join type(表示表的连接类型) possible_keys the possible indexes to choose(表示查询时，可能使用的索引) key the index actually chosen(表示实际使用的索引) key_len the length of the chosen key(索引字段的长度) ref the columns compared to the index(列与索引的比较) rows estimate of rows to be examined(扫描出的行数(估算的行数)) filtered percentage of rows filtered by table condition(按表条件过滤的行百分比) extra additional information(执行情况的描述和说明) idselect查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序 分三种情况: id相同，执行顺序从上到下 id不同，id越大越先被执行 id相同和id不同的值同时存在，id越大越先执行,id相同从上往下顺序执行 select_type主要用来分辨查询的类型，是普通查询还是联合查询还是子查询 select_type meaning simple 简单的查询，不包含子查询和union primary 查询中包含任何复杂的子查询，最外层查询被标记为primary union Second or later SELECT statement in a UNION(UNION中的第二个或后面的SELECT语句) dependent union Second or later SELECT statement in a UNION, dependent on outer query union result Result of a UNION(UNION的结果) subquery First SELECT in subquery(子查询中的第一个SELECT，结果不依赖于外部查询) dependent subquery First SELECT in subquery, dependent on outer query(子查询中的第一个SELECT，依赖于外部查询) derived Derived table(衍生表) uncacheable subquery 表示使用子查询的结果不能被缓存 uncacheable union 表示union的查询结果不能被缓存 table表示访问的是哪一张表，可能是临时表或结果集。 derivedN，表示查询产生的衍生表 union result 表名是union n1,n2形式，表示n1,n2的结果集 type表示的是访问类型，是以何种方式去访问我们的数据。效率从高到低依次是: system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range &gt;index&gt;all 一般情况下，保证查询至少达到range级别，最好能达到ref type meaning system 表只有一行记录（等于系统表），这是const类型的特例，平时不会出现 const 这个表至多有一个匹配行，例:explain select * from emp where empno = 7369; eq_ref 使用唯一性索引进行数据查找 ref 使用了非唯一性索引进行数据的查找 fulltext 全文检索 ref_or_null 类似REF，只是搜索条件连接字段的值可以为NULL index_merge 在查询过程中需要多个索引组合使用 unique_subquery 使用的是唯一索引关联子查询 index_subquery 使用索引关联子查询 range 查询的时候限制了范围，使用=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() 等操作符 index 全索引扫描主要有两种情况，一种是当前的查询时覆盖索引，explain select empno from emp;，或者是使用了索引进行排序，这样就避免数据的重排序 all 全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。 posible_keys表示可能被使用的索引，但不一定被查询实际使用 key实际使用的索引 key_len表示索引占用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。 ref列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 rows根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好 extra包含额外的信息 extra meaning using filesort 说明mysql无法利用索引进行排序，只能利用排序算法进行排序 using index 使用了覆盖索引 using where 使用where条件]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库行转列案例]]></title>
    <url>%2F2020%2F01%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1)把图1转换为图2 id type t_id value 100 1 1 张三101 1 2 刘二102 1 3 刘三200 2 1 男201 2 2 男202 2 3 女300 3 1 50301 3 2 30302 3 3 10 //图1 /* 图2将表的显示转换为姓名 性别 年龄 张三 男 50*/ 123456select min(case type when 1 then value end) as 姓名, min(case type when 2 then value end) as 性别, min(case type when 3 then value end) as 年龄 from testgroup by t_id; 2) 表内容：2005-05-09 胜2005-05-09 胜2005-05-09 负2005-05-09 负2005-05-10 胜2005-05-10 负2005-05-10 负 转换为如下； ​ 胜 负 2005-05-09 2 22005-05-10 1 2 12345select rq, count(case shengfu when &apos;胜&apos; then 1 end) as &apos;胜&apos;, count(case shengfu when &apos;负&apos; then 1 end) as &apos;负&apos; from tmp group by rq 3)把下图转换为指定格式 姓名 语文 数学 英语王五 89 56 89 1234567891011121314151617181920212223242526272829303132333435-- 第一种方法，使用case whenselect name as &apos;姓名&apos;, max(case subject when &apos;语文&apos; then score end) as &apos;语文&apos;, max(case subject when &apos;数学&apos; then score end) as &apos;数学&apos;, max(case subject when &apos;英语&apos; then score end) as &apos;英语&apos;from STUDENT_SCOREgroup by name-- 第二种方法使用joinselect t1.name,t1.score as &apos;语文&apos;,t2.score as &apos;数学&apos;,t3.score as &apos;英语&apos; from(select * from STUDENT_SCORE where subject=&apos;语文&apos;) t1 join(select * from STUDENT_SCORE where subject=&apos;数学&apos;) t2 on t1.name=t2.name join(select * from STUDENT_SCORE where subject=&apos;英语&apos;) t3 on t1.name=t3.name-- 第三种方法使用union allselect t.姓名,max(t.语文) as &apos;语文&apos;,max(t.数学) as &apos;数学&apos;,max(t.英语) as &apos;英语&apos; from(select name as &apos;姓名&apos;,score as &apos;语文&apos;,0 as &apos;数学&apos;,0 as &apos;英语&apos;from STUDENT_SCORE where subject=&apos;语文&apos; union all select name as &apos;姓名&apos;,0 as &apos;语文&apos;,score as &apos;数学&apos;,0 as &apos;英语&apos; from STUDENT_SCORE where subject=&apos;数学&apos; union all select name as &apos;姓名&apos;,0 as &apos;语文&apos;,0 as &apos;数学&apos;,score as &apos;英语&apos; from STUDENT_SCORE where subject=&apos;英语&apos;) tgroup by t.姓名-- 转换为下种/* 成绩&gt;=80优秀,&gt;=60及格否则不及格语文 数学 英语 及格 优秀 不及格 */select name as &apos;姓名&apos;, case when (max(case subject when &apos;语文&apos; then score end))&gt;=80 then &apos;优秀&apos; when (max(case subject when &apos;语文&apos; then score end))&gt;=60 then &apos;及格&apos;else &apos;不及格&apos; end as &apos;语文&apos; , case when (max(case subject when &apos;数学&apos; then score end))&gt;=80 then &apos;优秀&apos; when (max(case subject when &apos;数学&apos; then score end))&gt;=60 then &apos;及格&apos;else &apos;不及格&apos; end as &apos;数学&apos;, case when (max(case subject when &apos;英语&apos; then score end))&gt;=80 then &apos;优秀&apos; when (max(case subject when &apos;英语&apos; then score end))&gt;=60 then &apos;及格&apos;else &apos;不及格&apos; end as &apos;英语&apos;from STUDENT_SCOREgroup by name]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2019%2F12%2F31%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[lambda、streamlambda表达式可以替代只有一个抽象函数的接口实现，告别匿名内部类，代码看起来更简洁易懂 lambda表达式同时还提升了对集合、框架的迭代、遍历、过滤数据的操作 函数式接口 有且仅有一个抽象方法的接口叫做函数式接口。lambda表达式应用于任何有函数式接口的地方 1234567891011121314Runnable runnable = new Runnable() &#123;@Overridepublic void run() &#123;System.out.println(&quot;running...&quot;);&#125;&#125;;runnable.run();Runnable runnable1 = ()-&gt; System.out.println(&quot;running2&quot;);runnable1.run();//lambda用例()-&gt;&#123;&#125;()-&gt;&#123;return 100;&#125;()-&gt;100()-&gt;null(int x)-&gt;x+1x-&gt;x+1 方法引用 类名::方法名,实例对象::方法名 例:System.out::println stream之流操作 123456789101112131415161718List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);list.stream().filter(x-&gt;x%2==0).forEach(System.out::println);System.out.println(list.stream().filter(x -&gt; x % 2 == 1).mapToInt(x -&gt; x).sum());2 4 9//不会缓存中间结果，即返回值为Stream时的语句不会执行，只有执行终止语句才会执行streamStream&lt;Integer&gt; integerStream = list.stream().filter((x) -&gt; &#123;System.out.println(&quot;运行。。。&quot;);return x % 2 == 0;&#125;);System.out.println(integerStream);//不会执行filter中的语句，因为此语句的返回结果是stream属于中间操作，不会被缓存，只有对stream进行操作后返回非stream值时才会执行相应语句。System.out.println(integerStream.findFirst().get());//会执行filter的语句，因为.get()最后的返回值是一个int值.//把满足条件的值放到一个集合中List&lt;Integer&gt; collect = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toList());collect.forEach(System.out::println);//求数值相加和String str=&quot;11,22,33,44,55&quot;;System.out.println(Arrays.stream(str.split(&quot;,&quot;)).mapToInt(Integer::valueOf).sum());System.out.println(Arrays.stream(str.split(&quot;,&quot;)).map(Integer::valueOf).mapToInt(x -&gt; x).sum()); 自定义注解 使用@interface 来定义 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 元注解的作用是负责注解其他注解，java中定义了四个标准的元注解: @Target:用来描述注解的使用范围(注解可以用在什么地方) @Retention:表示需要在什么级别保存该注释信息，描述注解的生命周期 Source&lt;Class&lt;Runtime @Document:说明该注解将被包含在javadoc中 @Inherited:说明子类可以继承父类中的该注解]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js士兵行走案例]]></title>
    <url>%2F2019%2F12%2F31%2Fjs%E5%A3%AB%E5%85%B5%E8%A1%8C%E8%B5%B0%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;style&gt; *&#123; margin:0; padding:0; &#125; div&#123; position: absolute; width: 50px; height: 100px; background-image: url(&quot;./js/sb.png&quot;); background-position: 0px -200px; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //创建士兵 function Soldier()&#123; this.x=0; this.l=0; this.top=parseInt(Math.random()*500); this.isMove=true; this.init(); arr.push(this); this.click(); &#125; //动态创建div Soldier.prototype.init=function()&#123; this.dom =document.createElement(&quot;div&quot;); this.dom.style.top=this.top+&quot;px&quot;; document.body.appendChild(this.dom) &#125; //士兵行走 Soldier.prototype.walk=function()&#123; if(!this.isMove) return; if(this.x++ &gt;3) this.x=0; this.l+=10; if(this.l&gt;500)&#123; arr.splice(arr.indexOf(this),1); document.body.removeChild(this.dom); &#125; this.dom.style.backgroundPosition=-this.x*50+&quot;px -200px&quot;; this.dom.style.left=this.l+&quot;px&quot;; &#125; //定时行走 var time=0; var arr=[]; setInterval(function()&#123; if(time++ % 10 == 0)&#123; new Soldier(); &#125; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].walk(); &#125; &#125;,100) //点击事件 Soldier.prototype.click=function()&#123; var self=this; this.dom.onclick=function()&#123; self.isMove=!self.isMove; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础]]></title>
    <url>%2F2019%2F10%2F05%2Fredis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本介绍Redis 是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件，支持多种类型的数据结构,是单进程，单实例。 memcache和redis对比： memcache &lt;key,value&gt; value没有类型的概念 redis &lt;key,value&gt; value支持多种类型的多种方法。 例：“person,{name:’小明’,age:18}”当客户端需要获取value中的age时，memcache会返回所有value值，让客户端去遍历所需要的值 ，而redis会直接返回value相对应的age。本质上解耦，体现计算向数据移动。 数据库排名网站 ：https://db-engines.com/en/ redis中文网站：http:redis.cn redis官方网站: https://redis.io/ 基本语法string读取(范围/批量):get k1 / getrange k1 3 -1 / mget k1 k2 赋值(范围/批量):set k1 hello / getrange k1 2 -1 / mset k2 222 k3 333 set key nx 不存在时赋值，在分步式锁时使用​ set key xx 存在时赋值 append,strlength等等字符串基本语法 数值：递增)incr k1 / incrby k1 22 递减)decr k1 / decrby k1 2 redis是二进制安全的，需要和客户端沟通好编码类型. bitmap(位图):setbit,getbit ,bitcount,bitop 0(第0个字节) 1(第1个字节) 00000000（8位） 00000000(8位) 123456789101112131415161718192021127.0.0.1:6379&gt; setbit k1 1 1 //第0个字节第2位设置为1 即01000000127.0.0.1:6379&gt; get k1&quot;@&quot;127.0.0.1:6379&gt; setbit k1 10 1 //第2个字节第3位设置为1 即01000000127.0.0.1:6379&gt; get k1&quot;@ &quot;127.0.0.1:6379&gt; bitcount k1 0 0 //k1第0个字节有几个1(integer) 1127.0.0.1:6379&gt; bitcount k1 0 1 //k1第0至1个字节有几个1(integer) 2127.0.0.1:6379&gt; setbit k2 1 1127.0.0.1:6379&gt; setbit k2 7 1127.0.0.1:6379&gt; get k2 //01000001&quot;A&quot;127.0.0.1:6379&gt; setbit k3 1 1127.0.0.1:6379&gt; setbit k3 6 1127.0.0.1:6379&gt; get k3 //01000010&quot;B&quot;127.0.0.1:6379&gt; bitop and destkey k2 k3 //按位与操作结果为01000000127.0.0.1:6379&gt; get destkey&quot;@&quot; 位图场景 1)不定期统计用户登录天数 key为当前用户id,value为bitmap，每一位相当于天数，登录则为1，反之为0 1234setbit zs 1 1 //第2天登录设为1setbit zs 90 1 //第91天登录设为1setbit zs 364 1 //第365天登录设为1bitcount zs -7 -1 //统计最后一周登录天数 2）不定期统计活跃用户数量 key为时间，value为bitmap,每一位相当于一个用户id， 12345setbit 20191001 0 1 //2019年10月1号 张三登录setbit 20191002 0 1 //2019年10月2号 张三登录setbit 20191002 1 1 //2019年10月2号 李四登录bitop or destkey 20191001 20191002 //2019年10月1号至10月2号登录人数bitcount destkey 0 -1 //统计2019年10月1号至10月2号登录人数 list常用命令:lpush、lrange、lpop、lindex、lset、lrem、linsert、llen、ltrim rpush、range、rpop、blpoplist是重复有序的，包含了栈、队列、数组、单播订阅的概念 hash常用命令:hset、hmset、hget、hmget、hvals、hgetall 应用场景:点赞、收藏、详情页 set常用命令：sadd、smembers、sinter、sinterstore、sunion、sdiff、srandmember、spop 123456sadd k9 1 2 3 4 5 srandmember k9 3 //随机取三个，不会重复srandmember k9 -3 //随机取三个，会重复srandmember k9 10 //只能取出5个srandmember k9 -10 //随机取10个，会重复spop k9 //随机取1个，并把这个值去除 可用于年会抽奖，一人一份的场景 set是去重无序的.应用场景：随机抽奖 sorted_set常用命令:zadd、zrange、zrevrange、zscore、zrank、zunionscore 应用场景：排行榜 排序之所以快是因为使用skip_list(跳跃表)实现的。skip_list是一个分层结构多级链表，最下层是原始链表，每个层级都是下一个层级的“高速跑道”.跳表具有如下性质： 1)由很多层结构组成 2)每一层都是一个有序链表 3)最底层的链表包含所有元素 4)如果一个元素出现在 i层，则它在i层之下的链表也都会出现 5)每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。 IO模式及零拷贝bio 阻塞 nio 非阻塞 实现方式：select,poll,epoll 多路复用，同步非阻塞 aio 异步非阻塞 进程连接数 io效率 消息传递 select 有限 采用轮询方式，遍历所有fd判断是否就绪 用户态、内核态切换 poll 基于链表，没有限制 采用轮询方式，遍历所有fd判断是否就绪 用户态、内核态切换 epoll 有限，但是上限很大 采用回调机制，返回就绪fd mmap内存共享空间 epoll详解： epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制。 核心API:epoll_create,epoll_ctl,epoll_wait epoll_create生成epoll实例并返回一个文件描述符即epoll句柄，epoll_ctl,epoll_wait均以此为核心。 epoll_ctl 将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改 epoll_wait 向用户进程返回处于ready状态下的文件描述符列表 采用回调机制，在执行add操作时，将文件描述符放到红黑树上，同时注册回调函数，内核在检测到某fd可读/写时会调用此回调函数，该回调函数将文件描述符放在就绪链表中。 零拷贝sendfile 零拷贝是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间而直接在内核空间中传输到网络的方式，减少cpu的占用和内存带宽。 1、发出sendfile系统调用，用户空间和内核空间上下文切换（第1次上下文切换） 2、通过DMA将磁盘文件中的内容拷贝到内核空间缓冲区（第1次拷贝：hard driver-&gt;kernel buffer） 3、DMA发出中断，CPU处理中断，将数据从内核缓冲区拷贝到socket缓冲区(第2次拷贝：kener buffer -&gt; socket buffer) 4、sendfile系统调用返回，内核空间到用户空间上下文切换(第2次上下文切换) 5、通过DMA将socket缓冲区中的数据传递到网卡(第3次拷贝：socket buffer -&gt;网卡) 3次上下文切换，3次拷贝。 1、调用read()，上下文切换到内核，DMA把磁盘数据复制到内核缓冲区 2、read()返回，上下文切换到用户空间，CPU把数据复制到用户的缓存空间 3、write()上下文切换到内核，CPU把数据复制到socket缓冲区 4、write()返回，上下文切换到用户进程 5、DMA把socket缓冲区数据复制到网卡 4次上下文切换，4次拷贝。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis进阶]]></title>
    <url>%2F2019%2F10%2F05%2Fredis%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[发布订阅 publish/subscribe 1发布一条消息，2开始订阅，此时不会收到刚刚发布的消息 3 再次发布消息 此时订阅端才会收到发布的消息。订阅后不能看到订阅之前发布的消息。 事务123multi //开启事务set k1 123exec //执行事务 布隆过滤器布隆过滤器是一个bitmap,集合元素通过几种不同的哈希函数生成的哈希值映射到bit位设为1。只要有一个哈希值对应的bit位为0时就会认为不存在此元素。 可以使用布隆过滤器预防穿透，但是布隆过滤器不会保证百分百准确同时也不支持删除。 redis缓存缓存：1不是全量数据2缓存应该存放热数据3数据可以丢4 追求极速 数据库：1全量数据2数据不能丢3追求速度+持久性 回收策略: noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）(做数据库时使用此策略) allkeys-lru: 尝试回收最久使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最久使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-lfu:从所有键中驱逐使用频率最少的键。 volatile-lfu:从所有配置了过期时间的键中驱逐使用频率最少的键。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 根据业务来选择使用哪种策略，一般使用lru及lfu策略。 过期: 如果没有到达过期时间，发生写操作，那么过期时间会被剔除 过期判断原理: 1如果key已经过期，那么当客户端尝试访问时，key会被发现并主动过期 2周期轮询判定，直到过期的key的百分比低于25%redis持久化RDBrdb持久化方式能够在指定时间间隔对数据进行快照，具有时点性,通过SAVE和BGSAVE对数据集进行保存。 SAVE命令会阻塞redis的服务进程，直到rdb文件创建完毕为止。只有在目的明确时才使用，如关机等。 BGSAVE命令则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。 工作原理： Redis 调用forks. 同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。 rdb只有一个dump.rdb文件，如需历史数据需要手动维护。 【管道】管道是阻塞的，会触发子进程。常规下linux进程间数据是隔离的。 使用系统调用:fork()会产生一个新的子进程，子进程只会开辟一个虚拟空间，而物理空间(内核)是和父进程共享的（指向同一个指针），只有当进程的数据发生变化时才会在物理空间复制一份新的数据并在此空间进行写操作。这利用了copy on write（写时复制）,只有在数据变化写入时才会发生复制。 AOF（Append-only file）每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。 工作原理： Redis 执行 fork() ，现在同时拥有父进程和子进程。 子进程开始将新 AOF 文件的内容写入到临时文件。 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。 现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。 丢失数据 恢复速度 RDB 会丢失一个时点的数据，相对较大 体积相对小，恢复速度快 AOF 丢失数据少 体积相对大，恢复速度慢 推荐使用AOF和RDB两种方式，配置文件修改属性aof-usr-rdb-preamble yes表示开启AOF、RDB混合模式。这种模式只会生成一个aof文件，aof文件包含rdb及增量指令。只有触发BGREWRITEAOF 时aof才会包含rdb.如下： 主从复制主备、主从、主主概念可参考https://www.cnblogs.com/tankblog/p/11190598.html 主从和主备的区别是除了同步数据之外还得干活，对外提供读的操作。 REPLICAOF hostname port 当前服务器作为指定服务器的副本 REPLICAOF NO ONE 设置当前服务器为主服务器 sentinel (哨兵)sentinel是解决redis高可用的方案,可以监视多个主服务器及主服务器的从服务器，可以在主服务器挂掉的时候指定新的主服务器。 1234567//创建sentinel配置文件port 26379 //指定端口号//指定监听主服务器(本地6279端口)，2代表当有2个哨兵认为master失效时，master才算失效sentinel monitor mymaster localhost 6379 2 //启动哨兵redis-cli sentinel.conf --sentinel 如果主挂了哨兵会重新选一个主，然后让其他从跟随,哨兵(通过发布订阅)知道当前redis会有其他几个哨兵。 分区/分片redis集群中内置了 16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽. 使用哈希槽的好处就在于可以方便的添加或移除节点。 当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了； 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了； 扩展redis存在问题：单机故障，容量有量，压力 AKFAKF扩展立方、分别从XYZ轴展开，可以解决redis存在的问题 X轴:主从复制、高可用，通过克隆进行扩展 Y轴:业务拆分，通过拆分不同的东西进行扩展 Z轴:地域性划分，通过拆分相似的东西进行扩展 脑裂脑裂:高可用集群故障，由一个整体拆分成两部分都可以对外提供服务，导致数据不一致。搭建集群时设定的数量是奇数，可以防止脑裂。 例：AB两机房由于网络中断，分别对外提供服务。则对A进行插入操作，从B读取不到数据。如果A中的机器数量占整个集群的一半以上，那么B会自动宕机，由A来对外提供服务。 CAP（分布式的三大特性）Consistency(一致性): 读取的数据是写入的数据。 Availability(可用性):只要收到用户的请求，服务器就必须给出回应。 Partition tolerance(分区容忍性):必然存在网络故障断开的风险，这个网络断开的专业场景成为网络分区。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 CAP 原则指的是，这三个要素最多只能同时实现两点，实际只能保证CP、AP。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。 一致性哈希算法将哈希值空间组织成一个虚拟的圆环，将每台机器通过哈希算法映射到圆环上(物理节点)，将数据通过哈希算法映射到圆环，按顺时针找到下一个物理节点存储此数据。但不能保证每台机器数据分布均匀，可能会集中在某台机器上。这时可为每台机器虚拟出几个节点，这样会缓解数据倾倒。 面试常问击穿一个key或少量的key过期造成并发访问数据库.可以在客户端异步访问redis,第一个访问到的调用setnx(key timeout)从数据库取值,其他客户端访问如果没有得到值可更改setnx(key)的过期时间。 穿透查询数据是系统根本不存在的数据(黑客攻击)，可以使用布隆过滤器 雪崩大量的key同时失效.可以均匀设置过期时间，可以参考击穿方案使用分布式锁。 vim命令小技巧: .,$y 表示复制当前行到末行 Gp 从最后一行开始粘贴 工欲善其事，必先利其器。要学会利用官方网站、github。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程1]]></title>
    <url>%2F2019%2F09%2F26%2F%E7%BA%BF%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[创建方式 1)继承Thread类 2)实现Runnable接口 12345678910111213141516171819202122232425public class TestThread &#123; public static void main(String[] args) &#123; T1 t1 = new T1(); t1.setName(&quot;t1,继承Thread类&quot;); t1.start();//启动线程1 T2 t2 = new T2(); Thread thread = new Thread(t2); t1.setName(&quot;t2,实现Runnable接口&quot;); thread.start();//启动线程2 &#125;&#125;class T1 extends Thread&#123; @Override public void run()&#123; System.out.println(&quot;当前线程名称:&quot;+Thread.currentThread().getName()); &#125;&#125;class T2 implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;当前线程名称:&quot;+Thread.currentThread().getName()); &#125;&#125; 线程状态 New Runnable,细分为ready和running,调用start()方法进入ready,获得使用权后进入running Block,分为等待阻塞，超时等待阻塞及其他阻塞。调用sleep,wait等方法会造成阻塞 Teminated 常用方法join:暂停当前线程，执行join线程，等join线程执行完毕继续执行当前线程 123456789101112131415161718192021public class TestJoinThread &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); t1.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;主线程执行&quot;); &#125;&#125;class T1 extends Thread&#123; @Override public void run()&#123; for (int i=0;i&lt;100;i++)&#123; System.out.println(&quot;t1,第&quot;+i+&quot;次开始执行&quot;); &#125; &#125; //执行结果t1执行100次之后输出主线程执行，主线程要等到t1线程执行结束再执行 join方法可以使线程按自己定义的顺序执行 sleep和wait方法的区别： sleep属于Thread类的静态方法；wait属于Object类的方法 sleep不释放锁，使用interrupt方法打断；wait释放锁，会造成阻塞，使用notify方法唤醒 同步多个线程抢占同一资源需要加锁即synchronized，保证原子性。 锁升级：偏向锁、轻量级锁、重量级锁 有一个线程时会使用偏向锁，有线程竞争后会升级为轻量级锁，未获得锁的线程会自旋，当达到设定的自旋次数后依旧没有获得锁，会升级为重量级锁。 线程少、方法执行时间短的时候会使用轻量级锁，会占用cpu资源 线程多，执行时间长会使用重量级锁，不占用cpu资源，但会增加用户态和内核态的切换次数，系统开销比较大 生产者消费者案例篮子存放牛奶，生产者把牛奶放入篮子，消费者从篮子取出牛奶 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class TestSync &#123; public static void main(String[] args) &#123; Basket b = new Basket(); new Thread(new Producer(b)).start(); new Thread(new Consumer(b)).start(); &#125;&#125;//牛奶class Milk&#123; int id; Milk(int id)&#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;Milk:&quot;+id; &#125;&#125;/** * 篮子，篮子存放8盒牛奶，有放入和取出方法 * 涉及到同步，等待，唤醒, * 第1，2处使用while不使用if是因为会反复确认条件是否成立再向下执行 */class Basket&#123; Milk[] milks = new Milk[8]; int index = 0; public synchronized void push(Milk m)&#123; while(index == milks.length)&#123; //第1处 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); System.out.println(&quot;生产了:&quot;+index); milks[index] = m; index++; &#125; public synchronized Milk pop()&#123; while(index == 0)&#123; //第2处 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); index--; System.out.println(&quot;消费了:&quot;+index); return milks[index]; &#125;&#125;//生产者，生产牛奶放入篮子class Producer implements Runnable&#123; Basket b = new Basket(); Producer(Basket basket)&#123; this.b = basket; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; b.push(new Milk(i)); &#125; &#125;&#125;//消费者，从篮子里拿出牛奶class Consumer implements Runnable&#123; Basket b = new Basket(); Consumer(Basket basket)&#123; this.b = basket; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; b.pop(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮播图案例]]></title>
    <url>%2F2019%2F01%2F07%2F%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[部局：外层div，内层分为三部分分别是: ul部局 存放要轮播的图片 按钮部局，存放向左、向右的按钮 分页器部局 样式 div设为相对定位，调整整体高度，宽度 ul、li设为绝对定位，调整整体宽高，去除list样式，设置left值，使所有ul li均放在一个位置上重叠。 左右按钮设为绝对定位，调整宽高、向左(右)、向上的距离 分页器设为绝对定位，调整宽高、向左、向下的距离，ol li float向左对齐调整背景、颜色、透明度,设置当前选中页的背景、放大样式 js 向右点击事件，当前页及下一页向左滑动，分页器值跟着变动 向左点击事件，当前页及上一页向右滑动，分页器值跟着变动 自动轮播及鼠标移入(暂停轮播)、移出事件(轮播) 分页器点击具体分页跳转到相关图片，当前页向左滑动，选中的页向左滑动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="../../resources/css/default.css"&gt; &lt;script type="text/javascript" src="../../resources/js/jquery-3.4.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li class="current"&gt;&lt;img src="1.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="2.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="3.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="4.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="5.jpg"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;button class="lbtn"&gt;&amp;lt;&lt;/button&gt; &lt;button class="rbtn"&gt;&amp;gt;&lt;/button&gt; &lt;ol&gt; &lt;li class="cur"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //右侧按钮单击事件 //信号量 var idx =0; $(".rbtn").click(function()&#123; rhandle(); &#125;) //开启定时器，自动轮播 var timer=setInterval(rhandle,10000) function rhandle()&#123; //当前显示的这张图片从left为0位置运动到-500 $("ul li").eq(idx).css(&#123;"left":0&#125;).stop(true).animate(&#123; "left":-500 &#125;,200) //下一张图片从容器右侧动画进入 idx++; idx=idx&gt;4?0:idx; $("ul li").eq(idx).css(&#123;"left":500&#125;).stop(true).animate(&#123;"left":0&#125;,200); $("ol li").eq(idx).addClass("cur").siblings().removeClass("cur"); &#125; function lhandle()&#123; //当前显示的这张图片从left为0位置运动到500 $("ul li").eq(idx).css(&#123;"left":0&#125;).stop(true).animate(&#123; "left":500 &#125;,200) //下一张图片从容器右侧动画进入 idx--; idx=idx&lt;0?4:idx; $("ul li").eq(idx).css(&#123;"left":-500&#125;).stop(true).animate(&#123;"left":0&#125;,200); $("ol li").eq(idx).addClass("cur").siblings().removeClass("cur"); &#125; //鼠标移上事件 $("div").mouseenter(function()&#123; clearInterval(timer); &#125;) //鼠标移出事件 $("div").mouseleave(function()&#123; timer=setInterval(rhandle,10000) &#125;) //左侧按钮单击事件 $(".lbtn").click(function()&#123; lhandle(); &#125;) //分页器业务 $("ol li").click(function()&#123; //获取单击的那个分页器的li的索引值var index=$(this).index();$("ul li").eq(idx).css(&#123;"left":0&#125;).stop(true).animate(&#123;"left":-500&#125;,200);$("ul li").eq(index).css(&#123;"left":500&#125;).stop(true).animate(&#123;"left":0&#125;,200);idx=index;$("ol li").eq(idx).addClass("cur").siblings().removeClass("cur");&#125;)&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364*&#123; margin:0; padding:0;&#125;div&#123; position: relative; width: 500px; height: 400px; border:1px solid black; margin:50px auto; overflow: hidden;&#125;ul&#123; width: 500px; height:400px; list-style: none;&#125;ul li&#123; position: absolute; left:500px;&#125;img&#123; width: 500px; height:400px;&#125;.current&#123; left:0px;&#125;.lbtn&#123; position: absolute; width:35px; height:35px; left:0px; top:40%;&#125;.rbtn&#123; position: absolute; width:35px; height:35px; right:0px; top:40%;&#125;ol&#123; position: absolute; width:150px; height:25px; left:35%; bottom: 5px; list-style: none;&#125;ol li&#123; width:25px; height:25px; float:left; background:black; text-align: center; color:white; border-radius: 50%; margin-right: 3px;&#125;.cur&#123; background: green; transform: scale(1.2);&#125;]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
